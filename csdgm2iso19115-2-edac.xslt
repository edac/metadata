<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	FGDC CSDGM to ISO 19115-2 

	initial revisions: 2013, Earth Data Analysis Center
	
	This is based on the csdgm2iso19115-2.xslt provided by NOAA's National Coastal Data 
	Development Center (NCDDC). See the NCDDC version for more information regarding previous revisions:
	
		http://www.ncddc.noaa.gov/metadata-standards/metadata-xml/

	This XSLT has undergone significant revisions from the original source. Most, if not all, of the
	machine-generated code has been replaced and most of the loops have been refactored to avoid generating
	empty tags or better reflect the 0 to 1 FGDC constraints. In addition, we have added templates for 
	contacts, citations, dates/datetimes and spatial references. We have paid particular attention to revisions 
	for vector datasets. See the ea2fc revision for more information.
	
	Note also that, while we have tested this against a variety of FGDC xml, the transformation 
	may still contain gaps in its coverage. 

	Notes:
		- The output xml is an MI record. 
		- This assumes that the input FGDC xml is valid against the FGDC-STD-001-1998 or 
		  FGDC-STD-012-2002 (RSE) schemas. 
		- This XSLT does not contain transformation details for every spatial reference. See the 
		  spref section for more information on how to update the XSLT to include spatial reference
		  information for any sprefs not included here.
		- We have made every effort to ensure that all of the information contained in the 
		  input FGDC xml is captured in the ISO xml; however, this may not be possible in all cases.
		- ISO supports several equally valid structures within the distributionInfo element. This is
		  just one option.
		- Rolecodes are difficult to determine from the input FGDC. Adjust as needed.
	
	Dependencies:
		- ea2fc-edac.xsl: The FGDC entity attribute to ISO 19110 xml transformation. If the 
							    input FGDC  meets specific requirements, the 19110 xml will be 
							    automatically generated. Please see the parameter definitions (under
							    "FEATURE CATALOGUE PARAMS" below) for more information regarding 
							    the default options and usage.
	License: 
		The MIT License (MIT)

		Copyright (c) 2013 Earth Data Analysis Center
		
		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in
		all copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
		THE SOFTWARE.
-->
<!-- 
	ORIGINAL SOURCE: FGDC CSDGM to ISO 19115-2 Transform using XPath 2.0 June 2012

	This is the XML Style sheet that transforms metadata conforming to the Content Standards
	for Digital Geospatial Metadata of the Federal Geographic Data Committee June 1998 
	FGDC-STD-001-1999 version to the ISO 19115-2:2009(E).  This stylesheet can be applied
	to FGDC CSDGM XML to generate ISO 19115-2 XML.

	This file was generated by Altova MapForce 2009sp1

	Authors:
	This is the result of a collaboration of the Metadata Transform Working Group. 
	For further information, please contact NOAA's National Coastal Data 
	Development Center (NCDDC).
				National Coastal Data Development Center
				Toll Free: 866.732.2382
				E-mail: ncddcmetadata@noaa.gov
	
	Distribution Liability:
		NOAA makes no warranty regarding these data, expressed or implied, 
		nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		NODC and NCDDC cannot assume liability for any damages caused by any 
		errors or omissions in these data, nor as a result of the failure of these data 
		to function on a particular system. These files were developed for opensource uses.
	
	Use Constraints:
		The user is responsible for the results of any application of these transforms for other than its
		intended purpose. These transforms cannot guarantee valid output. Additional editing
		may need to be done in order to have valid records. The intent of these transforms is
		to get as much of the FGDC valid content mapped to ISO content as possible but cannot 
		guarantee against loss of information. Please feel free to edit transforms as needed for 
		your organizations needs. 
-->

<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmi="http://www.isotc211.org/2005/gmi" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" exclude-result-prefixes="fn grp vmf xs xsi xsl" xmlns="http://www.isotc211.org/2005/gmi">
	<xsl:output method="xml" encoding="UTF-8" indent="yes" name="mi"/>
	<xsl:output method="xml" encoding="UTF-8" indent="yes" name="fc"/>
	
	<!-- NOTE: update the reference to the local instance of the FC xsl -->
	<xsl:include href="ea2fc_with_mi_v2.xsl"/>
	
	<!-- get the name of the file (for the file identifier, etc) -->
	<xsl:param name="mi-identifier" select="fn:tokenize(fn:substring-before(fn:base-uri(.), '.xml'), '/')[last()]"/>
	
	<!-- prefix for the fileIdentifier element -->
	<xsl:param name="identifier-prefix" select="'identifier'" required="no"/>
	
	<!-- the urn (i.e. EDAC::Unknown) for any spref without an epsg/esri/etc code in the transform -->
	<xsl:param name="spref-unknown-urn"/>
	<!-- the url for any spref undefined in the transform -->
	<xsl:param name="spref-unknown-url"/>
	
	<!-- FEATURE CATALOGUE PARAMS -->
	<!-- path to the fc (19110) file if you need it (i.e. it's a vector dataset with attributes) 
	
		note: include trailing slashes
	-->	
	<xsl:param name="fc-out-path" required="no"/>
	
	<!-- url to the fc file (url + prefix + identifier + xml)
		ex: http://somewhere.com/metadata/19110/
		
		note: include trailing slashes
	-->
	<xsl:param name="fc-base-url" required="no"/>
	
	<!-- prefix for the output feature catalogue file (important if generating fc records in the same directory as the mi records) -->
	<xsl:param name="fc-prefix" required="no" select="'FC_'"/>
	
	<!-- iso codelist values/luts. renamed by the iso element for clarity. -->
	<xsl:template name="get-cellgeometrycode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT' or $input = 'PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL' or $input='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-sdstype">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT' or $input='ENTITY POINT' or $input='LABEL POINT' or $input='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH' or $input='NODE, NETWORK' or $input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='STRING' or $input='LINK' or $input='COMPLETE CHAIN' or $input='ELLIPTICAL ARC' or $input='UNIFORM B-SPLINE' or $input='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN' or $input='NETWORK CHAIN, NONPLANAR GRAPH' or $input='CIRCULAR ARC, THREE POINT CENTER' or $input='RING WITH MIXED COMPOSITION' 
				or $input='RING COMPOSED OF STRINGS' or $input='RING COMPOSED OF CHAINS' or $input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON' or $input='GT-POLYGON COMPOSED OF RINGS' or $input='GT-POLYGON COMPOSED OF CHAINS' or $input='UNIVERSE POLYGON COMPOSED OF RINGS' 
				or $input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-presentationformcode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS' or $input='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO' or $input='DIAGRAM' or $input='DOCUMENT' or $input='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MAP' or $input='RASTER DIGITAL DATA' or $input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODEL'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION' or $input='REMOTE-SENSING IMAGE' or $input='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION' or $input='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET' or $input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-progresscode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED' or $input='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING' or $input='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS' or $input='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-maintenancefreqcode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY' or $input='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED' or $input='NONE PLANNED' or $input='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-securityconstraintcode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-spatialrepcode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT' or $input='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-topiccode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='farming'">
				<xsl:value-of select="'farming'"/>
			</xsl:when>
			<xsl:when test="$input='biota'">
				<xsl:value-of select="'biota'"/>
			</xsl:when>
			<xsl:when test="$input='boundaries'">
				<xsl:value-of select="'boundaries'"/>
			</xsl:when>
			<xsl:when test="$input='climatologymeteorologyatmosphere'">
				<xsl:value-of select="'climatologyMeteorologyAtmosphere'"/>
			</xsl:when>
			<xsl:when test="$input='economy'">
				<xsl:value-of select="'economy'"/>
			</xsl:when>
			<xsl:when test="$input='elevation'">
				<xsl:value-of select="'elevation'"/>
			</xsl:when>
			<xsl:when test="$input='environment'">
				<xsl:value-of select="'environment'"/>
			</xsl:when>
			<xsl:when test="$input='geoscientificinformation'">
				<xsl:value-of select="'geoscientificInformation'"/>
			</xsl:when>
			<xsl:when test="$input='health'">
				<xsl:value-of select="'health'"/>
			</xsl:when>
			<xsl:when test="$input='imagerybasemapsearthcover'">
				<xsl:value-of select="'imageryBaseMapsEarthCover'"/>
			</xsl:when>
			<xsl:when test="$input='intelligencemilitary'">
				<xsl:value-of select="'intelligenceMilitary'"/>
			</xsl:when>
			<xsl:when test="$input='inlandwaters'">
				<xsl:value-of select="'inlandWaters'"/>
			</xsl:when>
			<xsl:when test="$input='location'">
				<xsl:value-of select="'location'"/>
			</xsl:when>
			<xsl:when test="$input='oceans'">
				<xsl:value-of select="'oceans'"/>
			</xsl:when>
			<xsl:when test="$input='planningcadastre'">
				<xsl:value-of select="'planningCadastre'"/>
			</xsl:when>
			<xsl:when test="$input='society'">
				<xsl:value-of select="'society'"/>
			</xsl:when>
			<xsl:when test="$input='structure'">
				<xsl:value-of select="'structure'"/>
			</xsl:when>
			<xsl:when test="$input='transportation'">
				<xsl:value-of select="'transportation'"/>
			</xsl:when>
			<xsl:when test="$input='utilitiescommunication'">
				<xsl:value-of select="'utilitiesCommunication'"/>
			</xsl:when>
			<xsl:when test="$input='ocean'">
				<xsl:value-of select="'oceans'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-mediumnamecode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM' or $input='CD ROM' or $input='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="get-mediumformatcode">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	
	<!-- core MI transformation -->
	<xsl:template match="/metadata">
		<gmi:MI_Metadata xsi:schemaLocation="http://www.isotc211.org/2005/gmi http://www.ngdc.noaa.gov/metadata/published/xsd/schema.xsd">
			<gmd:fileIdentifier>
				<gco:CharacterString>
					<!-- custom string (not really a urn)  
						example: RGIS::009df0fc-f044-4403-ab30-34a84feb678d::ISO-19115:2003
						
						where RGIS is the identifier-prefix param,
						009df0fc-f044-4403-ab30-34a84feb678d is the mi-identifier (i.e. file name),
						and ISO-19115:2003 is the metadata standard generated by this xslt
					-->
					<xsl:value-of select="fn:concat($identifier-prefix, '::', $mi-identifier, '::ISO-19115:2003')"/>
				</gco:CharacterString>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>eng; USA</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode"
					codeListValue="utf8">utf8</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode"
					codeListValue="dataset">dataset</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<gmd:contact>
				<xsl:apply-templates select="metainfo/metc/cntinfo" >
					<xsl:with-param name="rolecode" select="'pointOfContact'"/>
				</xsl:apply-templates>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:variable name='metdate' select="fn:normalize-space(metainfo/metd)"/>
				
				<xsl:variable name="met-datetime">
					<xsl:call-template name="format-datetime">
						<xsl:with-param name="datestring" select="$metdate"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="fn:contains($met-datetime, 'unknown') or fn:contains($met-datetime, 'present')">
						<xsl:attribute name="gco:nilReason" select="'unknown'"/>
					</xsl:when>
					<xsl:when test="fn:contains($met-datetime, 'T') and fn:contains($met-datetime, ':')">
						<gco:Date>
							<xsl:value-of select="fn:substring-before($met-datetime, 'T')"/>
						</gco:Date>
					</xsl:when>
					<xsl:otherwise>
						<gco:Date>
							<xsl:value-of select="$met-datetime"/>
						</gco:Date>
					</xsl:otherwise>
				</xsl:choose>
				
			</gmd:dateStamp>
			<!-- TODO: this should not be hardcoded (not everything is a raster) -->
			<gmd:metadataStandardName>
				<gco:CharacterString>ISO 19115-2 Geographic Information - Metadata - Part 2: Extensions for Imagery and Gridded Data</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>ISO 19115-2:2009(E)</gco:CharacterString>
			</gmd:metadataStandardVersion>
			
			<!-- 20130312 sscott: adding the dataSetURI for our MI requirements	-->
			<gmd:dataSetURI>
				<gco:CharacterString><xsl:value-of select="$mi-identifier"/></gco:CharacterString>
			</gmd:dataSetURI>
			
			<xsl:for-each select="spdoinfo">
				<gmd:spatialRepresentationInfo>
					<!-- for raster datasets -->
					<xsl:for-each select="rastinfo">
						<gmd:MD_GridSpatialRepresentation>
							<gmd:numberOfDimensions>
								<xsl:variable name="rowcnt" as="xs:integer?" select="(if (fn:exists(rowcount)) then 1 else 0)"/>
								<xsl:variable name="colcnt" as="xs:integer?" select="(if (fn:exists(colcount)) then 1 else 0)"/>
								<xsl:variable name="vrtcnt" as="xs:integer?" select="(if (fn:exists(vrtcount)) then 1 else 0)"/>
								<xsl:if test="$rowcnt or $colcnt or $vrtcnt">
									<gco:Integer>
										<xsl:value-of select="$rowcnt + $colcnt + $vrtcnt"/>
									</gco:Integer>
								</xsl:if>
							</gmd:numberOfDimensions>
							<!-- add each of the dimensions -->
							<xsl:if test="rowcount">
								<xsl:call-template name="spatial-rep-info">
									<xsl:with-param name="type" select="'row'"/>
									<xsl:with-param name="count" select="rowcount"/>
								</xsl:call-template>
							</xsl:if>
							<xsl:if test="colcount">
								<xsl:call-template name="spatial-rep-info">
									<xsl:with-param name="type" select="'column'"/>
									<xsl:with-param name="count" select="colcount"/>
								</xsl:call-template>
							</xsl:if>
							<xsl:if test="vrtcount">
								<xsl:call-template name="spatial-rep-info">
									<xsl:with-param name="type" select="'vertical'"/>
									<xsl:with-param name="count" select="vrtcount"/>
								</xsl:call-template>
							</xsl:if>	
							<gmd:cellGeometry>
								<xsl:variable name="cellgeometrycode" as="xs:string?">
									<xsl:call-template name="get-cellgeometrycode">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(rasttype))"/>
									</xsl:call-template>
								</xsl:variable>
								<gmd:MD_CellGeometryCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode"
									codeListValue="{$cellgeometrycode}"><xsl:value-of select="$cellgeometrycode"/></gmd:MD_CellGeometryCode>
							</gmd:cellGeometry>
							<!-- this is just unknown -->
							<gmd:transformationParameterAvailability gco:nilReason="unknown"/>
						</gmd:MD_GridSpatialRepresentation>
					</xsl:for-each>
					
					<!-- or vector datasets -->
					<xsl:for-each select="ptvctinf">
						<gmd:MD_VectorSpatialRepresentation>
							<xsl:for-each select="vpfterm">
								<gmd:topologyLevel>
									<gmd:MD_TopologyLevelCode codeSpace="{fn:normalize-space(vpflevel)}"/>
								</gmd:topologyLevel>
							</xsl:for-each>
							<xsl:for-each select="sdtsterm">
								<gmd:geometricObjects>
									<gmd:MD_GeometricObjects>
										<gmd:geometricObjectType>
											<!-- TODO: make sure there can't be multiple sdtstypes per element -->
											<xsl:variable name="sdts-type">
												<xsl:call-template name="get-sdstype">
													<xsl:with-param name="input" select="fn:upper-case(sdtstype)"/>
												</xsl:call-template>
											</xsl:variable>
											
											<xsl:if test="$sdts-type">
												<gmd:MD_GeometricObjectTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode"
													codeListValue="{$sdts-type}"/>
											</xsl:if>
										</gmd:geometricObjectType>
										<xsl:choose>
											<xsl:when test="ptvctcnt">
												<gmd:geometricObjectCount>
													<gco:Integer>
														<xsl:value-of select="ptvctcnt"/>
													</gco:Integer>
												</gmd:geometricObjectCount>
											</xsl:when>
											<xsl:otherwise>
												<gmd:geometricObjectCount gco:nilReason="unknown"/>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:MD_GeometricObjects>
								</gmd:geometricObjects>
							</xsl:for-each>
						</gmd:MD_VectorSpatialRepresentation>
					</xsl:for-each>
					</gmd:spatialRepresentationInfo>
			</xsl:for-each>
			
			<!-- include the indirect spatial reference -->
			<xsl:for-each select="spdoinfo">
				<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>
						<xsl:for-each select="indspref">
							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<gmd:code>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(.)"/>
										</gco:CharacterString>
									</gmd:code>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>
						</xsl:for-each>
					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
			</xsl:for-each>
			
			<!-- 
				Spatial Reference System Definition.
				
				PRIOR TO USE: Add or modify the tests below to reflect the spatial refs found in your metadata collection. Most 
				              of the sprefs found here are specific to New Mexico.
				
				Note: In most cases, we use www.epsg-registry.org as the spref authority with spatialreference.org as a secondary option. 
				      Bear this in mind modifying the URN/URI structures.
				              
				Note: If your FGDC is the result of a process using ArcCatalog and the MP cleanup tool, be aware that the MP tool
				      can strip out certain spref information for datasets using state plane projections. The end result is an
				      spref name that's truncated to 'Transverse Mercator' without the identifying state plane information. 
				      
				      This issue is not addressed here. This transformation will default to the unknown spref URN for any FGDC
				      identifying the spref as 'Transverse Mercator' only. 
			-->

			<!-- start with any grid system projections (utm, state plane, etc) -->
			<xsl:for-each select="spref/horizsys/planar/gridsys">
				<xsl:variable name="gridsys_name" select="gridsysn"/>
				<xsl:variable name="gridsys_zone">
					<xsl:choose>
						<xsl:when test="(fn:exists(utm))">
							<xsl:value-of select="utm/utmzone"/>
						</xsl:when>
						<xsl:when test="(fn:exists(spcs))">
							<xsl:value-of select="spcs/spcszone"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:sequence select="'-9999'"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="gridsys_datum" select="../../geodetic/horizdn"/>
				<!--  -->
				<xsl:variable name="gridsys_urn">
					<xsl:choose>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=11) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '27'))">
							<!-- for nad27 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26711')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=11) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '83'))">
							<!-- for nad83 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26911')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=12) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '27'))">
							<!-- for nad27 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26712')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=12) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '83'))">
							<!-- for nad83 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26912')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=13) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '27'))">
							<!-- for nad27 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26713')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=13) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '83'))">
							<!-- for nad83 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26913')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=15) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '27'))">
							<!-- for nad27 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26715')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=15) and ((contains($gridsys_datum, 'North American') or contains($gridsys_datum, 'NAD')) and contains($gridsys_datum, '83'))">
							<!-- for nad83 -->
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26915')"/>
						</xsl:when>
						<xsl:when test="contains($gridsys_name, 'State Plane') and ($gridsys_zone='3002' or (contains($gridsys_name,'New Mexico') and contains($gridsys_name,'Central')))">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:ESRI::102713')"/>
						</xsl:when>
						<xsl:when test="contains($gridsys_name, 'State Plane') and $gridsys_zone='3003'">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:ESRI::102714')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=13) and (contains($gridsys_datum, 'WGS') and contains($gridsys_datum, '84'))">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::32613')"/>
						</xsl:when>
						<xsl:when test="(contains($gridsys_name, 'Universal Transverse Mercator') or contains($gridsys_name, 'UTM')) and ($gridsys_zone=12) and (contains($gridsys_datum, 'WGS') and contains($gridsys_datum, '84'))">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::32612')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-urn"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="gridsys_uri">
					<xsl:choose>
						<xsl:when test="contains($gridsys_urn, 'ESRI::102713')">
							<xsl:value-of select="xs:string('http://spatialreference.org/ref/esri/102713/')"/>
						</xsl:when>
						<xsl:when test="contains($gridsys_urn, 'ESRI::102714')">
							<xsl:value-of select="xs:string('http://spatialreference.org/ref/esri/102714/')"/>
						</xsl:when>
						<xsl:when test="$gridsys_urn != $spref-unknown-urn">
							<xsl:value-of select="concat('http://www.epsg-registry.org/export.htm?gml=', $gridsys_urn)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-url"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="generate-spatialref">
					<xsl:with-param name="ref-name" select="concat($gridsys_name, ', ', $gridsys_zone)"/>
					<xsl:with-param name="ref-uri" select="$gridsys_uri"/>
					<xsl:with-param name="ref-urn" select="$gridsys_urn"/>
				</xsl:call-template>
			</xsl:for-each>
			<!-- for map projection -->
			<xsl:for-each select="spref/horizsys/planar/mapproj">
				<xsl:variable name="mapproj_name" select="mapprojn"/>
				<xsl:variable name="mapproj_datum" select="../../geodetic/horizdn"/>
				<xsl:variable name="mapproj_urn">
					<xsl:choose>
						<xsl:when test="$mapproj_name='NAD 1983 UTM Zone 13N'">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::26913')"/>
						</xsl:when>
						<xsl:when test="$mapproj_datum='D_North_American_1983_HARN' and contains($mapproj_name, 'Transverse Mercator')">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::2903')"/>
						</xsl:when>
						<xsl:when test="contains($mapproj_name, 'Lambert Conformal Conic') and contains($mapproj_datum, 'North American Datum') and contains($mapproj_datum, '83')">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:ESRI::102004')"/>
						</xsl:when>
						<xsl:when test="contains($mapproj_name, 'Lambert Azimuthal Equal Area') and contains($mapproj_datum, 'D_Sphere_Clarke_1866_Authalic')">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::2163')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-urn"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="mapproj_uri">
					<xsl:choose>
						<xsl:when test="contains($mapproj_urn, 'ESRI::102004')">
							<xsl:value-of select="xs:string('http://spatialreference.org/ref/esri/102004/')"/>
						</xsl:when>
						<xsl:when test="$mapproj_urn != $spref-unknown-urn">
							<xsl:value-of select="concat('http://www.epsg-registry.org/export.htm?gml=', $mapproj_urn)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-url"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="generate-spatialref">
					<xsl:with-param name="ref-name" select="$mapproj_name"/>
					<xsl:with-param name="ref-uri" select="$mapproj_uri"/>
					<xsl:with-param name="ref-urn" select="$mapproj_urn"/>
				</xsl:call-template>
			</xsl:for-each>
			<!-- the ellipsoid and the datum -->
			<xsl:for-each select="spref/horizsys/geodetic">
				<!-- start with the datum -->
				<xsl:variable name="datum_name" select="horizdn"/>
				<xsl:variable name="datum_urn">
					<!-- the urn (gmd:code) value for the datum -->
					<xsl:choose>
						<xsl:when test="(contains($datum_name, 'North American Datum') or contains($datum_name, 'NAD') or contains($datum_name, 'D North American')) and contains($datum_name, '83')">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::4269')"/>
						</xsl:when>
						<xsl:when test="(contains($datum_name, 'North American Datum') or contains($datum_name, 'NAD') or contains($datum_name, 'D North American')) and contains($datum_name, '27')">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::4267')"/>
						</xsl:when>
						<xsl:when test="$datum_name='D_Clarke_1866'">
							<xsl:value-of select="xs:string('urn:ogc:def:ellipsoid:EPSG::7008')"/>
						</xsl:when>
						<xsl:when test="contains($datum_name,'Clarke_1866') and contains($datum_name, 'Authalic')">
							<xsl:value-of select="xs:string('urn:ogc:def:ellipsoid:EPSG::7052')"/>
						</xsl:when>
						<xsl:when test="$datum_name='D_WGS_1984'">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::4326')"/>
						</xsl:when>
						<xsl:when test="$datum_name='D_North_American_1983_HARN'">
							<xsl:value-of select="xs:string('urn:ogc:def:datum:EPSG::6152')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-urn"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="datum_uri">
					<!-- the url to epsg-registry for the datum (because it's a handy way of re-using the urn variable) -->
					<xsl:choose>
						<xsl:when test="$datum_urn != $spref-unknown-urn">
							<xsl:value-of select="concat('http://www.epsg-registry.org/export.htm?gml=', $datum_urn)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-url"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="generate-spatialref">
					<xsl:with-param name="ref-name" select="$datum_name"/>
					<xsl:with-param name="ref-uri" select="$datum_uri"/>
					<xsl:with-param name="ref-urn" select="$datum_urn"/>
				</xsl:call-template>
				<xsl:variable name="ellipsoid_name" select="ellips"/>
				<xsl:variable name="ellipsoid_urn">
					<!-- the urn (gmd:code) value for the datum -->
					<xsl:choose>
						<xsl:when test="(contains($ellipsoid_name, 'Geodetic Reference System') or contains($ellipsoid_name, 'GRS')) and contains($ellipsoid_name, '80')">
							<xsl:value-of select="xs:string('urn:ogc:def:ellipsoid:EPSG::7019')"/>
						</xsl:when>
						<xsl:when test="contains($ellipsoid_name, 'Clarke') and contains($ellipsoid_name, '1866') and not(contains($ellipsoid_name, 'Authalic'))">
							<xsl:value-of select="xs:string('urn:ogc:def:ellipsoid:EPSG::7008')"/>
						</xsl:when>
						<xsl:when test="$ellipsoid_name = 'Sphere_Clarke_1866_Authalic'">
							<xsl:value-of select="xs:string('urn:ogc:def:ellipsoid:EPSG::7052')"/>
						</xsl:when>
						<xsl:when test="(contains($ellipsoid_name, 'WGS') or contains($ellipsoid_name, 'World Geodetic System')) and contains($ellipsoid_name, '84')">
							<xsl:value-of select="xs:string('urn:ogc:def:crs:EPSG::4326')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-urn"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="ellipsoid_uri">
					<!-- the url to epsg-registry for the datum (because it's a handy way of re-using the urn variable) -->
					<xsl:choose>
						<xsl:when test="$ellipsoid_urn != $spref-unknown-urn">
							<xsl:value-of select="concat('http://www.epsg-registry.org/export.htm?gml=', $ellipsoid_urn)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-url"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="generate-spatialref">
					<xsl:with-param name="ref-name" select="$ellipsoid_name"/>
					<xsl:with-param name="ref-uri" select="$ellipsoid_uri"/>
					<xsl:with-param name="ref-urn" select="$ellipsoid_urn"/>
				</xsl:call-template>
			</xsl:for-each>
			<!-- the vertical datum -->
			<xsl:for-each select="spref/vertdef">
				<xsl:variable name="vertdef_name" select="altsys/altdatum"/>
				<xsl:variable name="vertdef_urn">
					<!-- the urn (gmd:code) value for the vertical datum -->
					<xsl:choose>
						<xsl:when test="(contains($vertdef_name, 'North American Vertical Datum') or contains($vertdef_name, 'NAVD 88')) and contains($vertdef_name, '1988')">
							<xsl:value-of select="xs:string('urn:ogc:def:datum:EPSG::5103')"/>
						</xsl:when>
						<xsl:when test="contains($vertdef_name, 'National Geodetic Vertical Datum') or contains($vertdef_name, '1929')">
							<xsl:value-of select="xs:string('urn:ogc:def:datum:EPSG::5102')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-urn"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="vertdef_uri">
					<xsl:choose>
						<xsl:when test="$vertdef_urn != $spref-unknown-urn">
							<xsl:value-of select="concat('http://www.epsg-registry.org/export.htm?gml=', $vertdef_urn)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$spref-unknown-url"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="generate-spatialref">
					<xsl:with-param name="ref-name" select="$vertdef_name"/>
					<xsl:with-param name="ref-uri" select="$vertdef_uri"/>
					<xsl:with-param name="ref-urn" select="$vertdef_urn"/>
				</xsl:call-template>
			</xsl:for-each>

			<gmd:identificationInfo>
				<gmd:MD_DataIdentification>
					<gmd:citation>
						<xsl:apply-templates select="idinfo/citation/citeinfo"/>
					</gmd:citation>
					<gmd:abstract>
						<gco:CharacterString>
							<xsl:value-of select="fn:normalize-space(idinfo/descript/abstract)"/>
						</gco:CharacterString>
					</gmd:abstract>
					<gmd:purpose>
						<gco:CharacterString>
							<xsl:value-of select="fn:normalize-space(idinfo/descript/purpose)"/>
						</gco:CharacterString>
					</gmd:purpose>
					<xsl:if test="idinfo/datacred">
						<gmd:credit>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(idinfo/datacred)"/>
							</gco:CharacterString>
						</gmd:credit>
					</xsl:if>
					<gmd:status>
						<xsl:variable name="progress-code">
							<xsl:call-template name="get-progresscode">
								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(idinfo/status/progress))"/>
							</xsl:call-template>
						</xsl:variable>
							<gmd:MD_ProgressCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode"
								codeListValue="{$progress-code}"><xsl:value-of select="$progress-code"/></gmd:MD_ProgressCode>
					</gmd:status>
					<xsl:for-each select="idinfo/ptcontac">
						<gmd:pointOfContact>
							<xsl:apply-templates select="cntinfo">
								<xsl:with-param name="rolecode" select="'pointOfContact'"/>
							</xsl:apply-templates>
						</gmd:pointOfContact>
					</xsl:for-each>
					<gmd:resourceMaintenance>
						<gmd:MD_MaintenanceInformation>
							<gmd:maintenanceAndUpdateFrequency>
								<xsl:variable name="maint-freq-code" as="xs:string?">
									<xsl:call-template name="get-maintenancefreqcode">
										<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(idinfo/status/update))"/>
									</xsl:call-template>
								</xsl:variable>
									<gmd:MD_MaintenanceFrequencyCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode"
										codeListValue="{$maint-freq-code}"><xsl:value-of select="$maint-freq-code"/></gmd:MD_MaintenanceFrequencyCode>
							</gmd:maintenanceAndUpdateFrequency>
						</gmd:MD_MaintenanceInformation>
					</gmd:resourceMaintenance>
					<xsl:for-each select="eainfo/detailed/attr/attrmfrq">
						<gmd:resourceMaintenance>
							<gmd:MD_MaintenanceInformation>
								<gmd:maintenanceAndUpdateFrequency>
									<xsl:variable name="maint-update-code" as="xs:string?">
										<xsl:call-template name="get-maintenancefreqcode">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(.))"/>
										</xsl:call-template>
									</xsl:variable>
									<gmd:MD_MaintenanceFrequencyCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode"
										codeListValue="{$maint-update-code}"><xsl:value-of select="$maint-update-code"/></gmd:MD_MaintenanceFrequencyCode>
								</gmd:maintenanceAndUpdateFrequency>
								<gmd:updateScope>
									<gmd:MD_ScopeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode"
										codeListValue="attribute">attribute</gmd:MD_ScopeCode>
								</gmd:updateScope>
							</gmd:MD_MaintenanceInformation>
						</gmd:resourceMaintenance>
					</xsl:for-each>
					<xsl:for-each select="idinfo/browse">
						<gmd:graphicOverview>
							<gmd:MD_BrowseGraphic>
								<gmd:fileName>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(browsen)"/>
									</gco:CharacterString>
								</gmd:fileName>
								<gmd:fileDescription>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(browsed)"/>
									</gco:CharacterString>
								</gmd:fileDescription>
								<gmd:fileType>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(browset)"/>
									</gco:CharacterString>
								</gmd:fileType>
							</gmd:MD_BrowseGraphic>
						</gmd:graphicOverview>
					</xsl:for-each>
					
					<!-- NOTE: We have standardized our FGDC to include ISO Topic Categories as a theme element
						       identified with themekt='ISO 19115 Topic Categories'. That theme element is represented here
						       as the topicCategory and is excluded from the descriptiveKeywords set.
						       
						 Also, this generates a separate descriptiveKeywords block for each theme/place/stratum/temporal 
						 FGDC element found rather than grouping all themes, etc, into one ISO element.
					-->
					<xsl:for-each select="idinfo/keywords/theme[not(contains(themekt, 'ISO 19115'))]">
						<gmd:descriptiveKeywords>
							<gmd:MD_Keywords>
								<xsl:for-each select="themekey">
									<gmd:keyword>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(.)"/>
										</gco:CharacterString>
									</gmd:keyword>
								</xsl:for-each>
								<gmd:type>
									<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
										codeListValue="theme">theme</gmd:MD_KeywordTypeCode>
								</gmd:type>
								<gmd:thesaurusName>
									<gmd:CI_Citation>
										<gmd:title>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(themekt)"/>
											</gco:CharacterString>
										</gmd:title>
										<gmd:date gco:nilReason="unknown"/>
									</gmd:CI_Citation>
								</gmd:thesaurusName>
							</gmd:MD_Keywords>
						</gmd:descriptiveKeywords>
					</xsl:for-each>
					<xsl:for-each select="idinfo/keywords/place">
						<gmd:descriptiveKeywords>
							<gmd:MD_Keywords>
								<xsl:for-each select="placekey">
									<gmd:keyword>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(.)"/>
										</gco:CharacterString>
									</gmd:keyword>
								</xsl:for-each>
								<gmd:type>
									<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
										codeListValue="place">place</gmd:MD_KeywordTypeCode>
								</gmd:type>
								<gmd:thesaurusName>
									<gmd:CI_Citation>
										<gmd:title>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(placekt)"/>
											</gco:CharacterString>
										</gmd:title>
										<gmd:date gco:nilReason="unknown"/>
									</gmd:CI_Citation>
								</gmd:thesaurusName>
							</gmd:MD_Keywords>
						</gmd:descriptiveKeywords>
					</xsl:for-each>
					<xsl:for-each select="idinfo/keywords/stratum">
						<gmd:descriptiveKeywords>
							<gmd:MD_Keywords>
								<xsl:for-each select="stratkey">
									<gmd:keyword>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(.)"/>
										</gco:CharacterString>
									</gmd:keyword>
								</xsl:for-each>
								<gmd:type>
									<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
										codeListValue="stratum">stratum</gmd:MD_KeywordTypeCode>
								</gmd:type>
								<gmd:thesaurusName>
									<gmd:CI_Citation>
										<gmd:title>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(stratkt)"/>
											</gco:CharacterString>
										</gmd:title>
										<gmd:date gco:nilReason="unknown"/>
									</gmd:CI_Citation>
								</gmd:thesaurusName>
							</gmd:MD_Keywords>
						</gmd:descriptiveKeywords>
					</xsl:for-each>
					<xsl:for-each select="idinfo/keywords/temporal">
						<gmd:descriptiveKeywords>
							<gmd:MD_Keywords>
								<xsl:for-each select="tempkey">
									<gmd:keyword>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(.)"/>
										</gco:CharacterString>
									</gmd:keyword>
								</xsl:for-each>
								<gmd:type>
									<gmd:MD_KeywordTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode"
										codeListValue="temporal">temporal</gmd:MD_KeywordTypeCode>
								</gmd:type>
								<gmd:thesaurusName>
									<gmd:CI_Citation>
										<gmd:title>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(tempkt)"/>
											</gco:CharacterString>
										</gmd:title>
										<gmd:date gco:nilReason="unknown"/>
									</gmd:CI_Citation>
								</gmd:thesaurusName>
							</gmd:MD_Keywords>
						</gmd:descriptiveKeywords>
					</xsl:for-each>
				
					<gmd:resourceConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
									codeListValue="otherRestrictions">otherRestrictions</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
									codeListValue="otherRestrictions">otherRestrictions</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							
							<!-- 20130102 soren scott
								as per the best practices outlined in the workbook, but with checks for the existence of access constraints, use constraints and liability statement
								rather than just the one to include everything
							-->
							<gmd:otherConstraints>
								<xsl:variable name="useConstraints" >
									<xsl:choose>
										<xsl:when test="fn:exists(idinfo/useconst)">
											<xsl:value-of select="fn:concat('Use Constraints: ', idinfo/useconst)"/>
										</xsl:when>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="accessConstraints" >
									<xsl:choose>
										<xsl:when test="fn:exists(idinfo/accconst)">
											<xsl:value-of select="fn:concat('Access Constraints: ', idinfo/accconst)"/>
										</xsl:when>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="distLiability" >
									<xsl:choose>
										<xsl:when test="fn:exists(distinfo/distliab)">
											<xsl:value-of select="fn:concat('Distribution Liability: ', distinfo/distliab)"/>
										</xsl:when>
									</xsl:choose>
								</xsl:variable>
								<gco:CharacterString>
									<xsl:choose>
										<xsl:when test="$useConstraints[text() != ''] | $accessConstraints[text() != ''] | $distLiability[text() != '']">
											<xsl:value-of select="$useConstraints[text() != ''] | $accessConstraints[text() != ''] | $distLiability[text() != '']" separator=" | "/>
										</xsl:when>
										<xsl:otherwise>
											<!-- just in case everything is empty -->
											<xsl:value-of select="'None.'"/>
										</xsl:otherwise>
									</xsl:choose>
								</gco:CharacterString>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
					</gmd:resourceConstraints>
					<xsl:for-each select="idinfo/secinfo">
						<gmd:resourceConstraints>
							<gmd:MD_SecurityConstraints>
								<gmd:classification>
									<xsl:variable name="sec-constraint-code" as="xs:string?">
										<xsl:call-template name="get-securityconstraintcode">
											<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(secclass))"/>
										</xsl:call-template>
									</xsl:variable>
										<gmd:MD_ClassificationCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode"
											codeListValue="{$sec-constraint-code}"><xsl:value-of select="$sec-constraint-code"/></gmd:MD_ClassificationCode>
								</gmd:classification>
								<gmd:classificationSystem>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(secsys)"/>
									</gco:CharacterString>
								</gmd:classificationSystem>
								<gmd:handlingDescription>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(sechandl)"/>
									</gco:CharacterString>
								</gmd:handlingDescription>
							</gmd:MD_SecurityConstraints>
						</gmd:resourceConstraints>
					</xsl:for-each>
					<xsl:for-each select="idinfo/citation/citeinfo/lworkcit">
						<gmd:aggregationInfo>
							<gmd:MD_AggregateInformation>
								<gmd:aggregateDataSetName>
									<xsl:apply-templates select="citeinfo" >
										<xsl:with-param name="use-onlinks" select="true()"/>
									</xsl:apply-templates>
								</gmd:aggregateDataSetName>
								<gmd:associationType>
									<gmd:DS_AssociationTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode"
										codeListValue="largerWorkCitation">largerWorkCitation</gmd:DS_AssociationTypeCode>
								</gmd:associationType>
							</gmd:MD_AggregateInformation>
						</gmd:aggregationInfo>
					</xsl:for-each>
					<xsl:for-each select="idinfo/crossref">
						<gmd:aggregationInfo>
							<gmd:MD_AggregateInformation>
								<gmd:aggregateDataSetName>
									<xsl:apply-templates select="citeinfo" >
										<xsl:with-param name="use-onlinks" select="true()"/>
									</xsl:apply-templates>
								</gmd:aggregateDataSetName>
								<gmd:associationType>
									<gmd:DS_AssociationTypeCode codeList="http://www.ngdc.noaa.gov/metadata/published/xsd/schema/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode"
										codeListValue="crossReference">crossReference</gmd:DS_AssociationTypeCode>
								</gmd:associationType>
							</gmd:MD_AggregateInformation>
						</gmd:aggregationInfo>
					</xsl:for-each>
						
					<gmd:spatialRepresentationType>
						<xsl:variable name="spatial-rep-code" as="xs:string?">
							<xsl:call-template name="get-spatialrepcode">
								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(spdoinfo/direct))"/>
							</xsl:call-template>
						</xsl:variable>
							<gmd:MD_SpatialRepresentationTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode"
								codeListValue="{$spatial-rep-code}"><xsl:value-of select="$spatial-rep-code"/></gmd:MD_SpatialRepresentationTypeCode>
					</gmd:spatialRepresentationType>
					
					<gmd:language>
						<gco:CharacterString>eng; USA</gco:CharacterString>
					</gmd:language>
					
					<!-- TODO: deal with multiple themekeys if we need to (it just takes the first now) -->
					<xsl:if test="idinfo/keywords/theme[fn:contains(fn:lower-case(themekt), 'iso 19115 topic categories')]">
						<gmd:topicCategory>
							<xsl:variable name="topic">
								<xsl:call-template name="get-topiccode">
									<xsl:with-param name="input" select="fn:lower-case(idinfo/keywords/theme[fn:contains(fn:lower-case(themekt), 'iso 19115 topic categories')]/themekey[1])"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:if test="$topic">
								<gmd:MD_TopicCategoryCode>
									<xsl:value-of select="$topic"/>
								</gmd:MD_TopicCategoryCode>
							</xsl:if>
						</gmd:topicCategory>
					</xsl:if>

					<xsl:for-each select="idinfo/native">
						<!-- NOTE: removing the tech prereq for now (multiple distributions and could be duplicated) -->
						<gmd:environmentDescription>
								<gco:CharacterString>
									<xsl:value-of select="fn:normalize-space(fn:concat('Native Dataset Environment: ', fn:normalize-space(idinfo/native)))"/>
								</gco:CharacterString>
						</gmd:environmentDescription>
					</xsl:for-each>
					
					<gmd:extent>
						<gmd:EX_Extent id="{fn:concat('boundingExtent-', generate-id())}">
							<gmd:geographicElement>
								<xsl:for-each select="idinfo/spdom/dsgpoly">
									<gmd:EX_BoundingPolygon>
										<gmd:polygon>
											<gml:Polygon gml:id="{fn:concat('boundingPolygon-', generate-id())}">
												<gml:interior>
													<gml:LinearRing>
														<gml:coordinates>
															<!-- TODO: revise this (no edac example) -->
															<xsl:variable name="var602_map_select_grngpoin" as="xs:string*">
																<xsl:for-each select="dsgpolyo/grngpoin">
																	<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var599_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="fn:exists($var602_map_select_grngpoin)">
																		<xsl:for-each select="dsgpolyo/grngpoin">
																			<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double(gringlat)), ', '), xs:string(xs:double(gringlon))), '; ')"/>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="dsgpolyo/gring">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var599_cond_result_exists">
																<xsl:attribute name="decimal">
																	<xsl:sequence select="fn:normalize-space(.)"/>
																</xsl:attribute>
															</xsl:for-each>
														</gml:coordinates>
													</gml:LinearRing>
												</gml:interior>
											</gml:Polygon>
										</gmd:polygon>
									</gmd:EX_BoundingPolygon>
								</xsl:for-each>
								<gmd:EX_GeographicBoundingBox id="boundingGeographicBoundingBox">
									<gmd:westBoundLongitude>
										<gco:Decimal>
											<xsl:value-of select="idinfo/spdom/bounding/westbc"/>
										</gco:Decimal>
									</gmd:westBoundLongitude>
									<gmd:eastBoundLongitude>
										<gco:Decimal>
											<xsl:value-of select="idinfo/spdom/bounding/eastbc"/>
										</gco:Decimal>
									</gmd:eastBoundLongitude>
									<gmd:southBoundLatitude>
										<gco:Decimal>
											<xsl:value-of select="idinfo/spdom/bounding/southbc"/>
										</gco:Decimal>
									</gmd:southBoundLatitude>
									<gmd:northBoundLatitude>
										<gco:Decimal>
											<xsl:value-of select="idinfo/spdom/bounding/northbc"/>
										</gco:Decimal>
									</gmd:northBoundLatitude>
								</gmd:EX_GeographicBoundingBox>
							</gmd:geographicElement>
							<xsl:for-each select="idinfo/timeperd/timeinfo/sngdate">
								<gmd:temporalElement>
									<gmd:EX_TemporalExtent id="{fn:concat('boundingTemporalExtent','-',position()+1)}">
										<gmd:extent>
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="xs:string(fn:lower-case(fn:normalize-space(caldate)))"/>
												</xsl:attribute>
											</xsl:if>
											<gml:TimeInstant gml:id="{fn:concat('boundingTimeInstantExtent','-',position()+1)}">
												<gml:description>
													<xsl:value-of select="fn:normalize-space(idinfo/timeperd/current)"/>
												</gml:description>
												
												<xsl:variable name='caldate' select="fn:normalize-space(caldate)"/>
												<xsl:variable name='caltime' select="fn:normalize-space(time)"/>
												
												<xsl:variable name="cal-datetime">
													<xsl:call-template name="format-datetime">
														<xsl:with-param name="datestring" select="$caldate"/>
														<xsl:with-param name="timestring" select="$caltime"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:choose>
													<xsl:when test="fn:contains($cal-datetime, 'unknown')">
														<gml:timePosition/>
													</xsl:when>
													<xsl:when test="fn:contains($cal-datetime, 'present')">
														<gml:timePosition gco:indeterminatePosition="'now'"/>
													</xsl:when>
													<xsl:when test="fn:contains($cal-datetime, 'T') and fn:contains($cal-datetime, ':')">
														<gml:timePosition>
															<xsl:value-of select="$cal-datetime"/>
														</gml:timePosition>
													</xsl:when>
													<xsl:otherwise>
														<gml:timePosition>
															<xsl:value-of select="$cal-datetime"/>
														</gml:timePosition>
													</xsl:otherwise>
												</xsl:choose>
											</gml:TimeInstant>
										</gmd:extent>
									</gmd:EX_TemporalExtent>
								</gmd:temporalElement>
							</xsl:for-each>
							<xsl:for-each select="idinfo/timeperd/timeinfo/mdattim/sngdate">
								<gmd:temporalElement>
									<gmd:EX_TemporalExtent id="{fn:concat('boundingTemporalExtent','-', position()+1)}">
										<gmd:extent>
											<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="fn:lower-case(fn:normalize-space(caldate))"/>
												</xsl:attribute>
											</xsl:if>
											<gml:TimeInstant gml:id="{fn:concat('boundingTimeInstantExtent','-',position()+1)}">
												<gml:description>
													<xsl:value-of select="fn:normalize-space(idinfo/timeperd/current)"/>
												</gml:description>
												
												<xsl:variable name='caldate' select="fn:normalize-space(caldate)"/>
												<xsl:variable name='caltime' select="fn:normalize-space(time)"/>
												
												<xsl:variable name="cal-datetime">
													<xsl:call-template name="format-datetime">
														<xsl:with-param name="datestring" select="$caldate"/>
														<xsl:with-param name="timestring" select="$caltime"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:choose>
													<xsl:when test="fn:contains($cal-datetime, 'unknown')">
														<gml:timePosition/>
													</xsl:when>
													<xsl:when test="fn:contains($cal-datetime, 'present')">
														<gml:timePosition gco:indeterminatePosition="'now'"/>
													</xsl:when>
													<xsl:when test="fn:contains($cal-datetime, 'T') and fn:contains($cal-datetime, ':')">
														<gml:timePosition>
															<xsl:value-of select="$cal-datetime"/>
														</gml:timePosition>
													</xsl:when>
													<xsl:otherwise>
														<gml:timePosition>
															<xsl:value-of select="$cal-datetime"/>
														</gml:timePosition>
													</xsl:otherwise>
												</xsl:choose>
											</gml:TimeInstant>
										</gmd:extent>
									</gmd:EX_TemporalExtent>
								</gmd:temporalElement>
							</xsl:for-each>
							<xsl:for-each select="idinfo/timeperd/timeinfo/rngdates">
								<gmd:temporalElement>
									<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
										<xsl:attribute name="gco:nilReason">
											<xsl:value-of select="fn:lower-case(fn:normalize-space(begdate))"/>
										</xsl:attribute>
									</xsl:if>
									<gmd:EX_TemporalExtent id="{fn:concat('boundingTemporalExtent','-',position()+1)}">
										<gmd:extent>
											<gml:TimePeriod gml:id="boundingTimePeriodExtent">
												<gml:description>
													<xsl:value-of select="fn:normalize-space(idinfo/timeperd/current)"/>
												</gml:description>
												<!-- for the begin position-->
												<xsl:variable name='begdate' select="fn:normalize-space(begdate)"/>
												<xsl:variable name='begtime' select="fn:normalize-space(begtime)"/>
												
												<xsl:variable name="beg-datetime">
													<xsl:call-template name="format-datetime">
														<xsl:with-param name="datestring" select="$begdate"/>
														<xsl:with-param name="timestring" select="$begtime"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:choose>
													<xsl:when test="fn:contains($beg-datetime, 'unknown') or fn:contains($beg-datetime, 'present')">
														<gml:beginPosition/>
													</xsl:when>

													<xsl:when test="fn:contains($beg-datetime, 'T') and fn:contains($beg-datetime, ':')">
														<gml:beginPosition>
															<xsl:value-of select="$beg-datetime"/>
														</gml:beginPosition>
													</xsl:when>
													<xsl:otherwise>
														<gml:beginPosition>
															<xsl:value-of select="$beg-datetime"/>
														</gml:beginPosition>
													</xsl:otherwise>
												</xsl:choose>
												
												<!-- for the end position-->
												<xsl:variable name='enddate' select="fn:normalize-space(enddate)"/>
												<xsl:variable name='endtime' select="fn:normalize-space(endtime)"/>
												
												<xsl:variable name="end-datetime">
													<xsl:call-template name="format-datetime">
														<xsl:with-param name="datestring" select="$enddate"/>
														<xsl:with-param name="timestring" select="$endtime"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:choose>
													<xsl:when test="fn:contains($end-datetime, 'unknown') or fn:contains($end-datetime, 'present')">
														<gml:endPosition/>
													</xsl:when>
													<xsl:when test="fn:contains($end-datetime, 'T') and fn:contains($end-datetime, ':')">
														<gml:endPosition>
															<xsl:value-of select="$end-datetime"/>
														</gml:endPosition>
													</xsl:when>
													<xsl:otherwise>
														<gml:endPosition>
															<xsl:value-of select="$end-datetime"/>
														</gml:endPosition>
													</xsl:otherwise>
												</xsl:choose>
											</gml:TimePeriod>
										</gmd:extent>
									</gmd:EX_TemporalExtent>
								</gmd:temporalElement>
							</xsl:for-each>
						</gmd:EX_Extent>
					</gmd:extent>
					
					<xsl:if test="idinfo/descript/supplinf or (eainfo/overview and spdoinfo/direct = 'Raster')">
						<!-- in cases where we have a raster fgdc that contains any eainfo/overview text, we want to add that to supplemental info
							we don't need to worry about this for vectors - it is part of the feature catalogue description
						-->
						<xsl:variable name="supplinfo">
							<xsl:choose>
								<xsl:when test="idinfo/descript/supplinf">
									<xsl:value-of select="fn:normalize-space(idinfo/descript/supplinf)"/>
								</xsl:when>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="overview">
							<xsl:choose>
								<xsl:when test="eainfo/overview/eaover and spdoinfo/direct = 'Raster'">
									<xsl:value-of select="fn:normalize-space(eainfo/overview/eaover)"/>
								</xsl:when>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="eadetcit">
							<xsl:choose>
								<xsl:when test="eainfo/overview/eadetcit and spdoinfo/direct = 'Raster'">
									<xsl:value-of select="fn:normalize-space(eainfo/overview/eadetcit)"/>
								</xsl:when>
							</xsl:choose>
						</xsl:variable>
						
						<xsl:if test="$supplinfo or $overview or $eadetcit">
							<gmd:supplementalInformation>
								<gco:CharacterString>
									<xsl:value-of select="$supplinfo[text() != ''] | $overview[text() != ''] | $eadetcit[text() != '']" separator=" | "/>
								</gco:CharacterString>
							</gmd:supplementalInformation>
						</xsl:if>
					</xsl:if>
				</gmd:MD_DataIdentification>
			</gmd:identificationInfo>
			
			<xsl:if test="spdoinfo/direct='Vector'">
				<xsl:choose>
					<xsl:when test="eainfo/detailed">
						<!-- only include if we need to generate an external 19110 feature catalogue (for raster attribute data, see image description) -->
						<gmd:contentInfo>
							<gmd:MD_FeatureCatalogueDescription>
								<gmd:includedWithDataset>
									<gco:Boolean>true</gco:Boolean>
								</gmd:includedWithDataset>
								<xsl:for-each select="eainfo/detailed/enttyp">
									<gmd:featureTypes>
										<gco:LocalName codeSpace="{fn:normalize-space(enttypl)}"/>
									</gmd:featureTypes>
								</xsl:for-each>
								<gmd:featureCatalogueCitation>
									<!--	this should always run here - if not detailed, the whole contentinfo would be excluded	-->
									<gmd:CI_Citation>
										<gmd:title>
											<gco:CharacterString>Entity and Attribute Information</gco:CharacterString>
										</gmd:title>
										<gmd:date gco:nilReason="unknown"/>
										<gmd:citedResponsibleParty>
											<gmd:CI_ResponsibleParty>
												<gmd:contactInfo>
													<gmd:CI_Contact>
														<gmd:onlineResource>
															<gmd:CI_OnlineResource>
																<gmd:linkage>
																	<gmd:URL>
																		<xsl:value-of select="fn:concat($fc-base-url, $fc-prefix, $mi-identifier, '.xml')"/>
																	</gmd:URL>
																</gmd:linkage>
																<gmd:protocol>
																	<gco:CharacterString>http</gco:CharacterString>
																</gmd:protocol>
															</gmd:CI_OnlineResource>
														</gmd:onlineResource>
													</gmd:CI_Contact>
												</gmd:contactInfo>
												<gmd:role></gmd:role>
											</gmd:CI_ResponsibleParty>
										</gmd:citedResponsibleParty>
										<xsl:if test="eainfo/overview/eaover or eainfo/overview/eadetcit">
											<xsl:variable name="overview">
												<xsl:choose>
													<xsl:when test="eainfo/overview/eaover">
														<xsl:value-of select="fn:concat('Overview: ', eainfo/overview/eaover)"/>
													</xsl:when>
												</xsl:choose>
											</xsl:variable>
											<xsl:variable name="detailed-citation">
												<xsl:choose>
													<xsl:when test="eainfo/overview/eadetcit">
														<xsl:value-of select="fn:concat('Detailed Citation: ', eainfo/overview/eadetcit)"/>
													</xsl:when>
												</xsl:choose>
											</xsl:variable>
											<gmd:otherCitationDetails>
												<gco:CharacterString><xsl:value-of select="$overview[text() != ''] | $detailed-citation[text() != '']" separator=" | " /></gco:CharacterString>
											</gmd:otherCitationDetails>
										</xsl:if>
									</gmd:CI_Citation>
								</gmd:featureCatalogueCitation>
							</gmd:MD_FeatureCatalogueDescription>
						</gmd:contentInfo>
						
						<!-- generate the feature catalogue file -->
						<xsl:result-document href="{fn:concat($fc-out-path, $fc-prefix, $mi-identifier, '.xml')}" format="fc">
							<xsl:apply-templates mode="fc" select="../."/>
						</xsl:result-document>
					</xsl:when>
					<xsl:otherwise>
						<!-- we have a vector record but no attribute definitions. that's not great but here we are. -->
						<gmd:contentInfo>
							<gmd:MD_FeatureCatalogueDescription>
								<gmd:includedWithDataset>
									<gco:Boolean>false</gco:Boolean>
								</gmd:includedWithDataset>
								<xsl:for-each select="eainfo/detailed/enttyp">
									<gmd:featureTypes>
										<gco:LocalName codeSpace="{fn:normalize-space(enttypl)}"/>
									</gmd:featureTypes>
								</xsl:for-each>
								<xsl:choose>
									<xsl:when test="eainfo/overview/eaover or eainfo/overview/eadetcit">
										<xsl:variable name="overview">
											<xsl:choose>
												<xsl:when test="eainfo/overview/eaover">
													<xsl:value-of select="fn:concat('Overview: ', eainfo/overview/eaover)"/>
												</xsl:when>
											</xsl:choose>
										</xsl:variable>
										<xsl:variable name="detailed-citation">
											<xsl:choose>
												<xsl:when test="eainfo/overview/eadetcit">
													<xsl:value-of select="fn:concat('Detailed Citation: ', eainfo/overview/eadetcit)"/>
												</xsl:when>
											</xsl:choose>
										</xsl:variable>
										<gmd:featureCatalogueCitation>
											<gmd:CI_Citation>
												<gmd:title><gco:CharacterString>Entity and Attribute Information</gco:CharacterString></gmd:title>
												<gmd:date gco:nilReason="unknown"/>
												<gmd:citedResponsibleParty gco:nilReason="unknown"/>
												<gmd:otherCitationDetails>
													<gco:CharacterString><xsl:value-of select="$overview[text() != ''] | $detailed-citation[text() != '']" separator=" | " /></gco:CharacterString>
												</gmd:otherCitationDetails>
											</gmd:CI_Citation>
										</gmd:featureCatalogueCitation>
										
									</xsl:when>
									<xsl:otherwise>
										<gmd:featureCatalogueCitation gco:nilReason="unknown"/>
									</xsl:otherwise>
								</xsl:choose>
							</gmd:MD_FeatureCatalogueDescription>
						</gmd:contentInfo>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<!-- add this nice rastery bit if there's some actual attribute definition (we are assuming some sort of measurement here, like precipitation, etc, that has a unit associated with it) -->
			<xsl:if test="spdoinfo/direct='Raster' and eainfo/detailed">
				<gmd:contentInfo>
					<gmd:MD_CoverageDescription>
						<gmd:attributeDescription>
							<gco:RecordType/>
						</gmd:attributeDescription>
						<gmd:contentType>
							<!-- NOTE: this is just a default. -->
							<gmd:MD_CoverageContentTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CoverageContentTypeCode"
								codeListValue="physicalMeasurement">physicalMeasurement</gmd:MD_CoverageContentTypeCode>
						</gmd:contentType>
						<gmd:dimension>
							<xsl:variable name="raster-attr" select="eainfo/detailed/attr[1]"/>
							<gmd:MD_Band>
								<gmd:descriptor>
									<gco:CharacterString><xsl:value-of select="fn:concat($raster-attr/attrlabl, ' (', $raster-attr/attrdef, ')')"/></gco:CharacterString>
								</gmd:descriptor>
								<xsl:choose>
									<xsl:when test="$raster-attr/attrdomv/rdom/attrunit">
										<gmd:units>
											<gml:UnitDefinition gml:id="{generate-id($raster-attr)}">
												<!-- TODO: not sure what the identifier is meant to be -->
												<gml:identifier codeSpace=""/>
												<gml:name><xsl:value-of select="$raster-attr/attrdomv/rdom/attrunit"/></gml:name>
											</gml:UnitDefinition>
										</gmd:units>
									</xsl:when>
									<xsl:otherwise>
										<gmd:units gco:nilReason="unknown"/>
									</xsl:otherwise>
								</xsl:choose>
							</gmd:MD_Band>
						</gmd:dimension>
					</gmd:MD_CoverageDescription>
				</gmd:contentInfo>
			</xsl:if>
			<!-- and this if the raster has a cloudcover value -->
			<xsl:if test="dataqual/cloud or (not(dataqual/cloud) and spdoinfo/direct='Raster')">
				<!-- assume it's just an image or unknown without any attribute info, but if we have a raster with an attribute definition and cloud cover, we'll have 2 contentInfos-->
				<gmd:contentInfo>
					<gmd:MD_ImageDescription>
						<!-- TODO: not sure what this is meant to be -->
						<gmd:attributeDescription>
							<gco:RecordType/>
						</gmd:attributeDescription>
						<gmd:contentType>
							<gmd:MD_CoverageContentTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CoverageContentTypeCode"
								codeListValue="image">image</gmd:MD_CoverageContentTypeCode>
						</gmd:contentType>
						<xsl:choose>
							<xsl:when test="dataqual/cloud">
								<gmd:cloudCoverPercentage>
									<gco:Real><xsl:value-of select="dataqual/cloud"/></gco:Real>
								</gmd:cloudCoverPercentage>
							</xsl:when>
							<xsl:otherwise>
								<gmd:cloudCoverPercentage gco:nilReason="unknown"/>
							</xsl:otherwise>
						</xsl:choose>
					</gmd:MD_ImageDescription>
				</gmd:contentInfo>
			</xsl:if>

			<!-- this contains both the distinfo information and the idinfo/citation online linkages as possible options.
				 explicit handling of services, like wms, has not been incorporated.
			-->
			<gmd:distributionInfo>
				<gmd:MD_Distribution>
					<xsl:for-each select="distinfo/stdorder">
						<gmd:distributor>
							<gmd:MD_Distributor>
								<gmd:distributorContact>
									<xsl:apply-templates select="../distrib/cntinfo" >
										<xsl:with-param name="rolecode" select="'distributor'"/>
									</xsl:apply-templates>
								</gmd:distributorContact>
								<gmd:distributionOrderProcess>
									<gmd:MD_StandardOrderProcess>
										<gmd:fees>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(fees)"/>
											</gco:CharacterString>
										</gmd:fees>
										<xsl:for-each select="availabl">
											<gmd:plannedAvailableDateTime>
												<!-- options: valid datetime as gco:DateTime or plannedAvailableDateTime with nilReason 
													but there can be only one
												-->
												<xsl:variable name="availdate">
													<xsl:choose>
														<xsl:when test="timeinfo/sngdate/caldate">
															<xsl:value-of select="fn:normalize-space(timeinfo/sngdate/caldate)"/>
														</xsl:when>
														<xsl:when test="timeinfo/mdattime/sngdate">
															<xsl:value-of select="fn:normalize-space(timeinfo/mdattime/sngdate[1]/caldate)"/>
														</xsl:when>
														<xsl:when test="timeinfo/rngdates">
															<!-- just going with the beginning date time here. feel free to not do that. -->
															<xsl:value-of select="fn:normalize-space(timeinfo/rngdates/begdate)"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="'unknown'"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:variable name="availtime">
													<xsl:choose>
														<xsl:when test="timeinfo/sngdate/time">
															<xsl:value-of select="fn:normalize-space(timeinfo/sngdate/time)"/>
														</xsl:when>
														<xsl:when test="timeinfo/mdattime/sngdate and timeinfo/mdattime/sngdate[1]/time">
															<xsl:value-of select="fn:normalize-space(timeinfo/mdattime/sngdate[1]/time)"/>
														</xsl:when>
														<xsl:when test="timeinfo/rngdates and timeinfo/rngdates/begtime">
															<xsl:value-of select="fn:normalize-space(timeinfo/rngdates/begtime)"/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="'000000'"></xsl:value-of>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												
												<xsl:variable name="avail-datetime">
													<xsl:call-template name="format-datetime">
														<xsl:with-param name="datestring" select="$availdate"/>
														<xsl:with-param name="timestring" select="$availtime"/>
													</xsl:call-template>
												</xsl:variable>
												
												<xsl:choose>
													<xsl:when test="$avail-datetime = 'unknown'">
														<xsl:attribute name="gco:nilReason" select="$avail-datetime"/>
													</xsl:when>
													<xsl:otherwise>
														<gco:DateTime><xsl:value-of select="$avail-datetime"/></gco:DateTime>
													</xsl:otherwise>
												</xsl:choose>
											</gmd:plannedAvailableDateTime>
										</xsl:for-each>
										<xsl:for-each select="ordering">
<!--											20130128 soren scott
                                            revised to include a separator between the concatenated elements and to execute for any of the four elements, not just
                                            when the distinfo.custom element exists.
-->
											<xsl:variable name="distordering">
												<xsl:value-of select="fn:concat('Ordering Instructions: ', .)"/>
											</xsl:variable>
											<xsl:variable name="accinstr">
												<xsl:choose>
													<xsl:when test="fn:exists(../digform/digtopt/onlinopt/accinstr)">
														<xsl:value-of select="fn:concat('Access Instructions: ', ../digform/digtopt/onlinopt/accinstr)"/>
													</xsl:when>
												</xsl:choose>
											</xsl:variable>
											<xsl:variable name="nondigital">
												<xsl:choose>
													<xsl:when test="fn:exists(../nondig)">
														<xsl:value-of select="fn:concat('Non-Digital Form: ', ../nondig)"/>
													</xsl:when>
												</xsl:choose>
											</xsl:variable>
											<xsl:variable name="distcustom">
												<xsl:choose>
													<xsl:when test="fn:exists(../custom)">
														<xsl:value-of select="fn:concat('Custom Order Process: ', ../custom)"/>
													</xsl:when>
												</xsl:choose>
											</xsl:variable>
											<gmd:orderingInstructions>
												<gco:CharacterString>
													<xsl:choose>
														<xsl:when test="$distordering[text() != ''] | $accinstr[text() != ''] | $nondigital[text() != ''] | $distcustom[text() != '']">
															<xsl:value-of select="$distordering[text() != ''] | $accinstr[text() != ''] | $nondigital[text() != ''] | $distcustom[text() != '']" separator=" | "/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="'None.'"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:CharacterString>													
											</gmd:orderingInstructions>
										</xsl:for-each>
										<xsl:for-each select="turnarnd">
											<gmd:turnaround>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(.)"/>
												</gco:CharacterString>
											</gmd:turnaround>
										</xsl:for-each>
									</gmd:MD_StandardOrderProcess>
								</gmd:distributionOrderProcess>
								<gmd:distributorFormat>
									<gmd:MD_Format>
										<gmd:name>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(digform/digtinfo/formname)"/>
											</gco:CharacterString>
										</gmd:name>
										<!-- format version number OR format version date (but not both so the concat is unnecassary)
											 and no good place for the date in iso
										-->
										<xsl:choose>
											<xsl:when test="digform/digtinfo/formvern[fn:lower-case(text()) != 'unknown']">
												<gmd:version>
													<gco:CharacterString>
														<xsl:value-of select="fn:concat('Format Version Number: ', digform/digtinfo/formvern)"/>
													</gco:CharacterString>
												</gmd:version>
											</xsl:when>
											<xsl:when test="digform/digtinfo/formverd[fn:lower-case(text()) != 'unknown']">
												<gmd:version>
													<gco:CharacterString>
														<xsl:value-of select="fn:concat('Format Version Date: ', digform/digtinfo/formverd)"/>
													</gco:CharacterString>
												</gmd:version>
											</xsl:when>
											<xsl:otherwise>
												<gmd:version gco:nilReason="unknown"/>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:for-each select="digform/digtinfo/formspec">
											<gmd:specification>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(.)"/>
												</gco:CharacterString>
											</gmd:specification>
										</xsl:for-each>
										<xsl:for-each select="digform/digtinfo/filedec">
											<gmd:fileDecompressionTechnique>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(.)"/>
												</gco:CharacterString>
											</gmd:fileDecompressionTechnique>
										</xsl:for-each>
									</gmd:MD_Format>
								</gmd:distributorFormat>
								<gmd:distributorTransferOptions>
									<gmd:MD_DigitalTransferOptions>
										<xsl:for-each select="./digform/digtinfo/transize">
											<gmd:transferSize>
												<gco:Real>
													<xsl:value-of select="."/>
												</gco:Real>
											</gmd:transferSize>
										</xsl:for-each>
										
										<xsl:for-each select="./digform/digtopt/onlinopt/computer/networka/networkr"> 
											<gmd:onLine>
												<gmd:CI_OnlineResource>
													<gmd:linkage>
														<gmd:URL>
															<xsl:value-of select="fn:normalize-space(.)"/>
														</gmd:URL>
													</gmd:linkage>
													<xsl:for-each select="./digform/digtopt/onlinopt/oncomp"> 
														<gmd:description>
															<gco:CharacterString>
																<xsl:value-of select="fn:normalize-space(.)"/>
															</gco:CharacterString>
														</gmd:description>
													</xsl:for-each>
												</gmd:CI_OnlineResource>
											</gmd:onLine>
										</xsl:for-each>
										
										<!-- TODO: handle multiple offline option elements in fgdc (but only density and medium format can have multiple elements) -->
										<!-- note: this only handles a single offopt element (iso can only have one and the repeated elements within do not 
												   retain the connections between format, size, etc) even though the fgdc can have more than one (the problem is worse when 
												   you try to pack everything into the one element)
										-->
										<xsl:if test="./digform/digtopt/offoptn">
											<xsl:variable name="offopt" select="./digform/digtopt/offoptn[1]"/>
											<gmd:offLine>
												<gmd:MD_Medium>
													<gmd:name>
														<xsl:variable name="offmedia">
															<xsl:call-template name="get-mediumnamecode">
																<xsl:with-param name="input" select="fn:upper-case($offopt/offmedia)"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="$offmedia">
															<gmd:MD_MediumNameCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode"
																codeListValue="{$offmedia}"/>
														</xsl:if>
													</gmd:name>
													<xsl:if test="$offopt/reccap/recden">
														<gmd:density>
															<gco:Real><xsl:value-of select="$offopt/reccap/recden"/></gco:Real>
														</gmd:density>
													</xsl:if>
													<xsl:if test="reccap/recdenu">
														<gmd:densityUnits>
															<gco:CharacterString><xsl:value-of select="$offopt/reccap/recdenu"/></gco:CharacterString>
														</gmd:densityUnits>
													</xsl:if>
													<xsl:if test="recfmt">
														<gmd:mediumFormat>
															<xsl:variable name="rec-fmt" as="xs:string?">
																<xsl:call-template name="get-mediumformatcode">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space($offopt/rec-fmt))"/>
																</xsl:call-template>
															</xsl:variable>
															<gmd:MD_MediumFormatCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode"
																codeListValue="{$rec-fmt}"/>
														</gmd:mediumFormat>
													</xsl:if>
													<!-- TODO: add the digtinfo/formcont -->
													<xsl:if test="$offopt/compat">
														<gmd:mediumNote>
															<gco:CharacterString>
																<xsl:value-of select="$offopt/compat"/>
															</gco:CharacterString>
														</gmd:mediumNote>
													</xsl:if>
												</gmd:MD_Medium>
											</gmd:offLine>
										</xsl:if>
									</gmd:MD_DigitalTransferOptions>
								</gmd:distributorTransferOptions>
							</gmd:MD_Distributor>
						</gmd:distributor>
					</xsl:for-each>
					
					<!-- any online linkages from the idinfo/citation -->
					<gmd:transferOptions>
						<gmd:MD_DigitalTransferOptions>
							<xsl:for-each select="idinfo/citation/citeinfo/onlink">
								<gmd:onLine>
									<gmd:CI_OnlineResource>
										<gmd:linkage>
											<xsl:for-each select="fn:distinct-values(.)">
												<gmd:URL>
													<xsl:value-of select="fn:normalize-space(.)"/>
												</gmd:URL>
											</xsl:for-each>
										</gmd:linkage>
									</gmd:CI_OnlineResource>
								</gmd:onLine>
							</xsl:for-each>
						</gmd:MD_DigitalTransferOptions>
					</gmd:transferOptions>
				</gmd:MD_Distribution>
			</gmd:distributionInfo>
		
			<xsl:for-each select="dataqual">
				<gmd:dataQualityInfo>
					<gmd:DQ_DataQuality>
						<gmd:scope gco:nilReason="unknown" />
						
						<xsl:for-each select="posacc/horizpa/qhorizpa">
							<gmd:report>
								<gmd:DQ_AbsoluteExternalPositionalAccuracy>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of select="'Horizontal Positional Accuracy'"/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:measureDescription>
										<xsl:for-each select=".">
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(horizpae)"/>
											</gco:CharacterString>
										</xsl:for-each>
									</gmd:measureDescription>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(../horizpar)"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<gmd:DQ_QuantitativeResult>
											<gmd:valueUnit>
												<gml:BaseUnit gml:id="{fn:concat('meters-', generate-id(.))}">
													<gml:identifier codeSpace="meters"/>
													<gml:unitsSystem xlink:href="http://www.bipm.org/en/si/"/>
												</gml:BaseUnit>
											</gmd:valueUnit>
											<gmd:value>
												<xsl:for-each select=".">
													<gco:Record>
														<xsl:value-of select="horizpav"/>
													</gco:Record>
												</xsl:for-each>
											</gmd:value>
										</gmd:DQ_QuantitativeResult>
									</gmd:result>
								</gmd:DQ_AbsoluteExternalPositionalAccuracy>
							</gmd:report>
						</xsl:for-each>
						<xsl:for-each select="posacc/vertacc/qvertpa">
							<gmd:report>
								<gmd:DQ_AbsoluteExternalPositionalAccuracy>
									<gmd:nameOfMeasure>
										<gco:CharacterString>
											<xsl:value-of select="'Vertical Positional Accuracy'"/>
										</gco:CharacterString>
									</gmd:nameOfMeasure>
									<gmd:measureDescription>
										<xsl:for-each select=".">
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(vertacce)"/>
											</gco:CharacterString>
										</xsl:for-each>
									</gmd:measureDescription>
									<gmd:evaluationMethodDescription>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(../vertaccr)"/>
										</gco:CharacterString>
									</gmd:evaluationMethodDescription>
									<gmd:result>
										<gmd:DQ_QuantitativeResult>
											<gmd:valueUnit>
												<gml:BaseUnit gml:id="{fn:concat('meters-', generate-id(.))}">
													<!-- TODO: is this really what it should be? this doesn't match the other usage of codeSpace -->
													<gml:identifier codeSpace="meters"/>
													<gml:unitsSystem xlink:href="http://www.bipm.org/en/si/"/>
												</gml:BaseUnit>
											</gmd:valueUnit>
											<gmd:value>
												<xsl:for-each select=".">
													<gco:Record>
														<xsl:sequence select="vertaccv"/>
													</gco:Record>
												</xsl:for-each>
											</gmd:value>
										</gmd:DQ_QuantitativeResult>
									</gmd:result>
								</gmd:DQ_AbsoluteExternalPositionalAccuracy>
							</gmd:report>
						</xsl:for-each>
						<gmd:report>
							<gmd:DQ_CompletenessCommission>
								<gmd:result gco:nilReason="unknown" />
							</gmd:DQ_CompletenessCommission>
						</gmd:report>
						<gmd:report>
							<gmd:DQ_CompletenessOmission>
								<gmd:evaluationMethodDescription>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(complete)"/>
									</gco:CharacterString>
								</gmd:evaluationMethodDescription>
								<!-- NOTE: should always be unknown (there's no true!) -->
								<gmd:result gco:nilReason="unknown"/>
							</gmd:DQ_CompletenessOmission>
						</gmd:report>
						<gmd:report>
							<gmd:DQ_ConceptualConsistency>
								<gmd:measureDescription>
									<gco:CharacterString>
										<xsl:value-of select="fn:normalize-space(logic)"/>
									</gco:CharacterString>
								</gmd:measureDescription>
								<gmd:result gco:nilReason="unknown" />
							</gmd:DQ_ConceptualConsistency>
						</gmd:report>
						<xsl:for-each select="attracc">
							<xsl:for-each select="qattracc">
								<gmd:report>
									<gmd:DQ_QuantitativeAttributeAccuracy>
										<gmd:nameOfMeasure>
											<gco:CharacterString>
												<xsl:value-of select="'Quantitative Attribute Accuracy Assessment'"/>
											</gco:CharacterString>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(attracce)"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<xsl:for-each select="attraccr">
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit gml:id="{fn:concat('meters-', generate-id(.))}">
														<gml:identifier codeSpace="meters"/>
														<gml:unitsSystem xlink:href="http://www.bipm.org/en/si/"/>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="attraccv">
														<gco:Record>
															<xsl:value-of select="fn:normalize-space(.)"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_QuantitativeAttributeAccuracy>
								</gmd:report>
							</xsl:for-each>
						</xsl:for-each>
						<gmd:lineage>
							<gmd:LI_Lineage>
								<xsl:for-each select="lineage/procstep">
									<gmd:processStep>
										<gmd:LI_ProcessStep>
											<gmd:description>
												<gco:CharacterString>
													<xsl:value-of select="fn:normalize-space(procdesc)"/>
												</gco:CharacterString>
											</gmd:description>
											<gmd:dateTime>
												<xsl:variable name='procdate' select="fn:normalize-space(procdate)"/>
												<xsl:variable name='proctime' select="if (proctime) then fn:normalize-space(proctime) else '000000'"/>
												
												<xsl:variable name="proc-datetime">
													<xsl:call-template name="format-datetime">
														<xsl:with-param name="datestring" select="$procdate"/>
														<xsl:with-param name="timestring" select="$proctime"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:choose>
													<xsl:when test="fn:contains($proc-datetime, 'unknown') or fn:contains($proc-datetime, 'present')">
														<xsl:attribute name="gco:nilReason" select="'unknown'"/>
													</xsl:when>
													<xsl:otherwise>
														<gco:DateTime>
															<xsl:value-of select="$proc-datetime"/>
														</gco:DateTime>
													</xsl:otherwise>
												</xsl:choose>
											</gmd:dateTime>
											<xsl:for-each select="proccont">
												<gmd:processor>
													<xsl:apply-templates select="cntinfo">
														<xsl:with-param name="rolecode" select="'producer'"/>
													</xsl:apply-templates>
												</gmd:processor>
											</xsl:for-each>
											
											<!-- handle the srcused/srcprod elements
												
												 note: this doesn't check for the source's existence (through srccitea)
											
											-->
											<xsl:if test="srcprod">
												<xsl:for-each select="srcprod">
													<gmd:source>
														<gmd:LI_Source>
															<gmd:sourceCitation>
																<gmd:CI_Citation>
																	<gmd:title>
																		<gco:CharacterString><xsl:value-of select="'Source Produced'"/></gco:CharacterString>
																	</gmd:title>
																	<gmd:alternateTitle>
																		<gco:CharacterString>
																			<xsl:value-of select="fn:normalize-space(.)"/>
																		</gco:CharacterString>
																	</gmd:alternateTitle>
																	<gmd:date gco:nilReason="unknown"/>
																</gmd:CI_Citation>
															</gmd:sourceCitation>
														</gmd:LI_Source>
													</gmd:source>
												</xsl:for-each>
											</xsl:if>
											
											<xsl:if test="srcused">
												<xsl:for-each select="srcused">
													<gmd:source>
														<gmd:LI_Source>
															<gmd:sourceCitation>
																<gmd:CI_Citation>
																	<gmd:title>
																		<gco:CharacterString><xsl:value-of select="'Source Used'"/></gco:CharacterString>
																	</gmd:title>
																	<gmd:alternateTitle>
																		<gco:CharacterString>
																			<xsl:value-of select="fn:normalize-space(.)"/>
																		</gco:CharacterString>
																	</gmd:alternateTitle>
																	<gmd:date gco:nilReason="unknown"/>
																</gmd:CI_Citation>
															</gmd:sourceCitation>
														</gmd:LI_Source>
													</gmd:source>
												</xsl:for-each>
											</xsl:if>
										</gmd:LI_ProcessStep>
									</gmd:processStep>
								</xsl:for-each>
								<xsl:for-each select="lineage/srcinfo">
									<gmd:source>
										<gmd:LI_Source>
											<gmd:description>
												<gco:CharacterString>
													<xsl:variable name="type">
														<xsl:choose>
															<xsl:when test="typesrc">
																<xsl:value-of select="fn:concat('Source Type: ', typesrc)"/>
															</xsl:when>
														</xsl:choose>
													</xsl:variable>
													<xsl:variable name="cont">
														<xsl:choose>
															<xsl:when test="srccontr">
																<xsl:value-of select="fn:concat('Source Contribution: ', srccontr)"/>
															</xsl:when>
														</xsl:choose>
													</xsl:variable>
													<xsl:value-of select="$cont[text() != ''] | $type[text() != '']" separator=" | "/>
												</gco:CharacterString>
											</gmd:description>
											<gmd:scaleDenominator>
												<gmd:MD_RepresentativeFraction>
													<gmd:denominator>
														<xsl:choose>
															<xsl:when test="not(srcscale) or fn:lower-case(srcscale) = 'unknown'">
																<xsl:attribute name="gco:nilReason" select="'unknown'"/>
															</xsl:when>
															<xsl:otherwise>
																<gco:Integer><xsl:value-of select="srcscale"/></gco:Integer>
															</xsl:otherwise>
														</xsl:choose>
													</gmd:denominator>
												</gmd:MD_RepresentativeFraction>
											</gmd:scaleDenominator>
											<gmd:sourceCitation>
												<xsl:apply-templates select="srccite/citeinfo">
													<xsl:with-param name="use-onlinks" select="true()"/>
												</xsl:apply-templates>
											</gmd:sourceCitation>
											<gmd:sourceExtent>
												<gmd:EX_Extent>
													<xsl:for-each select="srctime/timeinfo/sngdate">
														<gmd:temporalElement>
															<gmd:EX_TemporalExtent>
																<gmd:extent>
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="fn:lower-case(fn:normalize-space(fn:string(caldate)))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<gml:TimeInstant gml:id="{fn:concat('sourceTemporalExtent-', generate-id())}">
																		<gml:description>
																			<xsl:value-of select="fn:normalize-space(srctime/srccurr)"/>
																		</gml:description>
																		
																		<xsl:variable name='caldate' select="fn:normalize-space(caldate)"/>
																		<xsl:variable name='caltime' select="fn:normalize-space(time)"/>
																		
																		<xsl:variable name="cal-datetime">
																			<xsl:call-template name="format-datetime">
																				<xsl:with-param name="datestring" select="$caldate"/>
																				<xsl:with-param name="timestring" select="$caltime"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:contains($cal-datetime, 'unknown')">
																				<gml:timePosition/>
																			</xsl:when>
																			<xsl:when test="fn:contains($cal-datetime, 'present')">
																				<gml:timePosition gco:indeterminatePosition="'now'"/>
																			</xsl:when>
																			<xsl:when test="fn:contains($cal-datetime, 'T') and fn:contains($cal-datetime, ':')">
																				<gml:timePosition>
																					<xsl:value-of select="$cal-datetime"/>
																				</gml:timePosition>
																			</xsl:when>
																			<xsl:otherwise>
																				<gml:timePosition>
																					<xsl:value-of select="$cal-datetime"/>
																				</gml:timePosition>
																			</xsl:otherwise>
																		</xsl:choose>
																	</gml:TimeInstant>
																</gmd:extent>
															</gmd:EX_TemporalExtent>
														</gmd:temporalElement>
													</xsl:for-each>
													<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
														<gmd:temporalElement>
															<gmd:EX_TemporalExtent>
																<gmd:extent>
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(caldate))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:value-of select="fn:lower-case(fn:normalize-space(fn:string(caldate)))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<gml:TimeInstant gml:id="{fn:concat('sourceTemporalExtent-', generate-id())}">
																		<gml:description>
																			<xsl:value-of select="xs:string(srctime/srccurr)"/>
																		</gml:description>
																		
																		<xsl:variable name='caldate' select="fn:normalize-space(caldate)"/>
																		<xsl:variable name='caltime' select="fn:normalize-space(time)"/>
																		
																		<xsl:variable name="cal-datetime">
																			<xsl:call-template name="format-datetime">
																				<xsl:with-param name="datestring" select="$caldate"/>
																				<xsl:with-param name="timestring" select="$caltime"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:contains($cal-datetime, 'unknown')">
																				<gml:timePosition/>
																			</xsl:when>
																			<xsl:when test="fn:contains($cal-datetime, 'present')">
																				<gml:timePosition gco:indeterminatePosition="'now'"/>
																			</xsl:when>
																			<xsl:when test="fn:contains($cal-datetime, 'T') and fn:contains($cal-datetime, ':')">
																				<gml:timePosition>
																					<xsl:value-of select="$cal-datetime"/>
																				</gml:timePosition>
																			</xsl:when>
																			<xsl:otherwise>
																				<gml:timePosition>
																					<xsl:value-of select="$cal-datetime"/>
																				</gml:timePosition>
																			</xsl:otherwise>
																		</xsl:choose>
																	</gml:TimeInstant>
																</gmd:extent>
															</gmd:EX_TemporalExtent>
														</gmd:temporalElement>
													</xsl:for-each>
													<xsl:for-each select="srctime/timeinfo/rngdates">
														<gmd:temporalElement>
															<gmd:EX_TemporalExtent>
																<gmd:extent>
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(begdate))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="fn:lower-case(fn:normalize-space(fn:string(begdate)))"/>
																		</xsl:attribute>
																	</xsl:if>
																	<gml:TimePeriod gml:id="{fn:concat('sourceTemporalExtent-', generate-id())}">
																		<gml:description>
																			<xsl:value-of select="fn:normalize-space(srctime/srccurr)"/>
																		</gml:description>
																		
																		<!-- for the begin position-->
																		<xsl:variable name='begdate' select="fn:normalize-space(begdate)"/>
																		<xsl:variable name='begtime' select="fn:normalize-space(begtime)"/>
																		
																		<xsl:variable name="beg-datetime">
																			<xsl:call-template name="format-datetime">
																				<xsl:with-param name="datestring" select="$begdate"/>
																				<xsl:with-param name="timestring" select="$begtime"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:contains($beg-datetime, 'unknown') or fn:contains($beg-datetime, 'present')">
																				<gml:beginPosition/>
																			</xsl:when>
																			
																			<xsl:when test="fn:contains($beg-datetime, 'T') and fn:contains($beg-datetime, ':')">
																				<gml:beginPosition>
																					<xsl:value-of select="$beg-datetime"/>
																				</gml:beginPosition>
																			</xsl:when>
																			<xsl:otherwise>
																				<gml:beginPosition>
																					<xsl:value-of select="$beg-datetime"/>
																				</gml:beginPosition>
																			</xsl:otherwise>
																		</xsl:choose>
																		
																		<!-- for the end position-->
																		<xsl:variable name='enddate' select="fn:normalize-space(enddate)"/>
																		<xsl:variable name='endtime' select="fn:normalize-space(endtime)"/>
																		
																		<xsl:variable name="end-datetime">
																			<xsl:call-template name="format-datetime">
																				<xsl:with-param name="datestring" select="$enddate"/>
																				<xsl:with-param name="timestring" select="$endtime"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:contains($end-datetime, 'unknown') or fn:contains($end-datetime, 'present')">
																				<gml:endPosition/>
																			</xsl:when>
																			<xsl:when test="fn:contains($end-datetime, 'T') and fn:contains($end-datetime, ':')">
																				<gml:endPosition>
																					<xsl:value-of select="$end-datetime"/>
																				</gml:endPosition>
																			</xsl:when>
																			<xsl:otherwise>
																				<gml:endPosition>
																					<xsl:value-of select="$end-datetime"/>
																				</gml:endPosition>
																			</xsl:otherwise>
																		</xsl:choose>
																	</gml:TimePeriod>
																</gmd:extent>
															</gmd:EX_TemporalExtent>
														</gmd:temporalElement>
													</xsl:for-each>
												</gmd:EX_Extent>
											</gmd:sourceExtent>
										</gmd:LI_Source>
									</gmd:source>
								</xsl:for-each>
							</gmd:LI_Lineage>
						</gmd:lineage>
					</gmd:DQ_DataQuality>
				</gmd:dataQualityInfo>
			</xsl:for-each>
			
			<xsl:if test="metainfo[metuc or metac]">
				<gmd:metadataConstraints>
					<gmd:MD_LegalConstraints>
						<xsl:if test="metainfo/metac">
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
									codeListValue="otherRestrictions">otherRestrictions</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
						</xsl:if>
						
						<xsl:if test="metainfo/metuc">
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
									codeListValue="otherRestrictions"/>
							</gmd:useConstraints>
						</xsl:if>
						<gmd:otherConstraints>
							<xsl:variable name="metaUseConstraints">
								<xsl:choose>
									<xsl:when test="fn:exists(metainfo/metuc)">
										<xsl:value-of select="fn:concat('Metadata Use Constraints: ', fn:normalize-space(metainfo/metuc))"/>
									</xsl:when>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="metaAccessConstraints">
								<xsl:choose>
									<xsl:when test="fn:exists(metainfo/metac)">
										<xsl:value-of select="fn:concat('Metadata Access Constraints: ', fn:normalize-space(metainfo/metac))"/>
									</xsl:when>
								</xsl:choose>
							</xsl:variable>
							<gco:CharacterString>
								<xsl:choose>
									<xsl:when test="$metaUseConstraints[text() != ''] | $metaAccessConstraints[text() != '']">
										<xsl:value-of select="$metaUseConstraints[text() != ''] | $metaAccessConstraints[text() != '']" separator=" | "/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="'None.'"/>
									</xsl:otherwise>
								</xsl:choose>
							</gco:CharacterString>
						</gmd:otherConstraints>
					</gmd:MD_LegalConstraints>
				</gmd:metadataConstraints>
			</xsl:if>
			
			<xsl:for-each select="metainfo/metsi">
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<gmd:classification>
							<xsl:variable name="security-code" as="xs:string?">
								<xsl:call-template name="get-securityconstraintcode">
									<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(metsc))"/>
								</xsl:call-template>
							</xsl:variable>
							<gmd:MD_ClassificationCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode"
								codeListValue="{$security-code}"/>
						</gmd:classification>
						<gmd:classificationSystem>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(metscs)"/>
							</gco:CharacterString>
						</gmd:classificationSystem>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency gco:nilReason="unknown" />
					<xsl:for-each select="metainfo/metfrd">
						<gmd:dateOfNextUpdate>					
							<xsl:variable name='frddate' select="fn:normalize-space(.)"/>
							
							<xsl:variable name="frd-datetime">
								<xsl:call-template name="format-datetime">
									<xsl:with-param name="datestring" select="$frddate"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:choose>
								<xsl:when test="fn:contains($frd-datetime, 'unknown') or fn:contains($frd-datetime, 'present')">
									<xsl:attribute name="gco:nilReason" select="'unknown'"/>
								</xsl:when>
								<xsl:when test="fn:contains($frd-datetime, 'T') and fn:contains($frd-datetime, ':')">
									<gco:Date>
										<xsl:value-of select="fn:substring-before($frd-datetime, 'T')"/>
									</gco:Date>
								</xsl:when>
								<xsl:otherwise>
									<gco:Date>
										<xsl:value-of select="$frd-datetime"/>
									</gco:Date>
								</xsl:otherwise>
							</xsl:choose>
							
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:variable name="rd-string">
							<xsl:choose>
								<xsl:when test="metainfo/metrd">
									<xsl:variable name='rddate' select="fn:normalize-space(metainfo/metrd)"/>
									<xsl:variable name="rd-datetime">
										<xsl:call-template name="format-datetime">
											<xsl:with-param name="datestring" select="$rddate"/>
										</xsl:call-template>
									</xsl:variable>
									
									<xsl:value-of select="fn:concat('Metadata Review Date: ', $rd-datetime)"/>
								</xsl:when>
							</xsl:choose>
						</xsl:variable>
						
						<gco:CharacterString>
							<xsl:value-of select="fn:concat('This metadata was automatically generated from the ', metainfo/metstdn, ' (version ', metainfo/metstdv, ') using the EDAC version of the FGDC CSDGM to ISO 19115-2 transform. ', $rd-string)"/>
						</gco:CharacterString>
						
					</gmd:maintenanceNote>
					<gmd:contact>
						<xsl:apply-templates select="metainfo/metc/cntinfo" >
							<xsl:with-param name="rolecode" select="'custodian'"/>
						</xsl:apply-templates>		
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmi:MI_Metadata>
	</xsl:template>

	<!-- standardized datetime function.
		
		 note: in almost all cases, it defaults to unknown if not a true date/datetime
		 
	-->
	<xsl:template name="format-datetime">
		<xsl:param name="datestring" select="()"/>
		<xsl:param name="timestring" select="()"/>
		
		<!-- this just builds the string, not the element with the string (you still need to do whatever unknown, etc, checks)		-->
		<xsl:choose>
			<xsl:when test="fn:contains(fn:lower-case($datestring), 'present')">
				<!-- to act as a trigger for any now() generated datetime -->
				<xsl:value-of select="'present'"/>
			</xsl:when>
			<xsl:when test="(fn:contains(fn:lower-case(fn:normalize-space($datestring)), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space($datestring)), 'unpublished') or fn:contains(fn:lower-case(fn:string($datestring)), 'not complete'))">
				<!-- just unknown from this -->
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="year">
					<xsl:value-of select="fn:substring($datestring, 1, 4)"/>
				</xsl:variable>
				<xsl:variable name="month">
					<xsl:choose>
						<xsl:when test="fn:string-length($datestring) > 4">
							<xsl:value-of select="fn:substring($datestring, 5, 2)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="'01'"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="day">
					<xsl:choose>
						<xsl:when test="fn:string-length($datestring) > 6">
							<xsl:value-of select="fn:substring($datestring, 7, 2)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="'01'"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				
				<xsl:choose>
					<xsl:when test="$datestring and (not($timestring) or fn:contains(fn:lower-case($timestring), 'unknown'))">
						<!-- we only have the date-->
						<xsl:value-of select="$year[text() != ''] | $month[text() != ''] | $day[text() != '']" separator="-"/>
					</xsl:when>
					<xsl:otherwise>
						<!-- we should have a good date and time and the time can't be anything less than HHmmss in fgdc-->
						<xsl:variable name="hours">
							<xsl:value-of select="fn:substring($timestring, 1, 2)"/>
						</xsl:variable>
						<xsl:variable name="minutes">
							<xsl:value-of select="fn:substring($timestring, 3, 2)"/>
						</xsl:variable>
						<xsl:variable name="seconds">
							<xsl:value-of select="fn:substring($timestring, 5, 2)"/>
						</xsl:variable>
						
						<!-- generate the new date structure-->
						<xsl:variable name="new-date">
							<xsl:value-of select="$year[text() != ''] | $month[text() != ''] | $day[text() != '']" separator="-"/>
						</xsl:variable>
						<xsl:variable name="new-time">
							<xsl:value-of select="$hours[text() != ''] | $minutes[text() != ''] | $seconds[text() != '']" separator=":"/>
						</xsl:variable>
						
						<xsl:value-of select="fn:concat($new-date, 'T', $new-time)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- to generate the spatial ref chunks for any datum, ellipsoid, grid ref, map projection elements -->
	<xsl:template name="generate-spatialref">
		<xsl:param name="ref-name" select="()"/>
		<xsl:param name="ref-uri" select="()"/>
		<xsl:param name="ref-urn" select="()"/>
		<!-- see the spatial ref sections for the values of each of these, but the urn/uri values are pointers to spatialreference.org or epsg-registry.org
		or whatever wkt/proj/gml definition of the spatialref you need to use -->
		<gmd:referenceSystemInfo>
			<gmd:MD_ReferenceSystem>
				<gmd:referenceSystemIdentifier>
					<gmd:RS_Identifier>
						<gmd:authority>
							<gmd:CI_Citation>
								<gmd:title>
									<gco:CharacterString>
										<xsl:value-of select="$ref-name"/>
									</gco:CharacterString>
								</gmd:title>
								<gmd:date>
									<gmd:CI_Date>
										<gmd:date gco:nilReason="unknown"/>
										<gmd:dateType>
											<gmd:CI_DateTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode"
												codeListValue="revision"/>
										</gmd:dateType>
									</gmd:CI_Date>
								</gmd:date>
								<gmd:citedResponsibleParty>
									<gmd:CI_ResponsibleParty>
										<gmd:contactInfo>
											<gmd:CI_Contact>
												<gmd:onlineResource>
													<gmd:CI_OnlineResource>
														<gmd:linkage>
															<gmd:URL>
																<xsl:value-of select="$ref-uri"/>
															</gmd:URL>
														</gmd:linkage>
													</gmd:CI_OnlineResource>
												</gmd:onlineResource>
											</gmd:CI_Contact>
										</gmd:contactInfo>
										<gmd:role>
											<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
												codeListValue="resourceProvider"/>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</gmd:citedResponsibleParty>
							</gmd:CI_Citation>
						</gmd:authority>
						<gmd:code>
							<gco:CharacterString>
								<xsl:value-of select="$ref-urn"/>
							</gco:CharacterString>
						</gmd:code>
					</gmd:RS_Identifier>
				</gmd:referenceSystemIdentifier>
			</gmd:MD_ReferenceSystem>
		</gmd:referenceSystemInfo>
	</xsl:template>
	
	<!-- for the raster spatial representation elements (row, column, vertical) -->
	<xsl:template name="spatial-rep-info">
		<xsl:param name="type"/>
		<xsl:param name="count"/>
		
		<gmd:axisDimensionProperties>
			<gmd:MD_Dimension>
				<gmd:dimensionName>
					<gmd:MD_DimensionNameTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
						codeListValue="{$type}"/>
				</gmd:dimensionName>
				<gmd:dimensionSize>
					<gco:Integer>
						<xsl:value-of select="$count"/>
					</gco:Integer>
				</gmd:dimensionSize>
			</gmd:MD_Dimension>
		</gmd:axisDimensionProperties>
	</xsl:template>

	<!-- generic contact template -->
	<xsl:template match="cntinfo" name="contact">
		<xsl:param name="rolecode"/>
		<gmd:CI_ResponsibleParty>
			<!-- TODO: which to pick - organization person or person person? -->
			<xsl:choose>
				<xsl:when test="cntperp/cntper">
					<gmd:individualName>
						<gco:CharacterString>
							<xsl:value-of select="fn:normalize-space(cntperp/cntper)"/>
						</gco:CharacterString>
					</gmd:individualName>
				</xsl:when>
				<xsl:when test="cntorgp/cntper">
					<gmd:individualName>
						<gco:CharacterString>
							<xsl:value-of select="fn:normalize-space(cntorgp/cntper)"/>
						</gco:CharacterString>
					</gmd:individualName>
				</xsl:when>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="cntperp/cntorg">
					<gmd:organisationName>
						<gco:CharacterString>
							<xsl:sequence select="fn:normalize-space(cntperp/cntorg)"/>
						</gco:CharacterString>
					</gmd:organisationName>
				</xsl:when>
				<xsl:when test="cntorgp/cntorg">
					<gmd:organisationName>
						<gco:CharacterString>
							<xsl:sequence select="fn:normalize-space(cntorgp/cntorg)"/>
						</gco:CharacterString>
					</gmd:organisationName>
				</xsl:when>
			</xsl:choose>
			
			<xsl:if test="cntpos">
				<gmd:positionName>
					<gco:CharacterString>
						<xsl:sequence select="fn:normalize-space(cntpos)"/>
					</gco:CharacterString>
				</gmd:positionName>
			</xsl:if>

			<gmd:contactInfo>
				<gmd:CI_Contact>
					<gmd:phone>
						<gmd:CI_Telephone>
							<xsl:if test="cntvoice">
								<gmd:voice>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(cntvoice)"/>
									</gco:CharacterString>
								</gmd:voice>
							</xsl:if>
							<xsl:if test="cntfax">
								<gmd:facsimile>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(cntfax)"/>
									</gco:CharacterString>
								</gmd:facsimile>
							</xsl:if>
						</gmd:CI_Telephone>
					</gmd:phone>
					
					<xsl:for-each select="cntaddr">
						<gmd:address>
							<gmd:CI_Address>
								<xsl:for-each select="address">
									<gmd:deliveryPoint>
										<gco:CharacterString>
											<xsl:value-of select="fn:normalize-space(.)"/>
										</gco:CharacterString>
									</gmd:deliveryPoint>
									<xsl:if test="city">
										<gmd:city>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(city)"/>
											</gco:CharacterString>
										</gmd:city>
									</xsl:if>
									<xsl:if test="state">
										<gmd:administrativeArea>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(state)"/>
											</gco:CharacterString>
										</gmd:administrativeArea>
									</xsl:if>
									<xsl:if test="postal">
										<gmd:postalCode>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(postal)"/>
											</gco:CharacterString>
										</gmd:postalCode>
									</xsl:if>
									<xsl:if test="country">
										<gmd:country>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(country)"/>
											</gco:CharacterString>
										</gmd:country>
									</xsl:if>
									
									<xsl:if test="../cntemail">
										<gmd:electronicMailAddress>
											<gco:CharacterString>
												<xsl:value-of select="fn:normalize-space(../cntemail)"/>
											</gco:CharacterString>
										</gmd:electronicMailAddress>
									</xsl:if>
								</xsl:for-each>
							</gmd:CI_Address>
						</gmd:address>
					</xsl:for-each>
					
					<xsl:if test="hours">
						<gmd:hoursOfService>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(hours)"/>
							</gco:CharacterString>
						</gmd:hoursOfService>
					</xsl:if>
					
					<xsl:if test="cntinst">
						<gmd:contactInstructions>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(cntinst)"/>
							</gco:CharacterString>
						</gmd:contactInstructions>
					</xsl:if>
				</gmd:CI_Contact>
			</gmd:contactInfo>
			<gmd:role>
				<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
					codeListValue="{$rolecode}"><xsl:value-of select="$rolecode"/></gmd:CI_RoleCode>
			</gmd:role>
		</gmd:CI_ResponsibleParty>
	</xsl:template>
	
	<!-- generic citation template
		note: this can't be used everwhere a citation is used (very specific citation structure for certain areas)
	-->
	<xsl:template match="citeinfo">
		<!-- default: exclude any onlinks (idinfo citation onlinks can be found in the distributionInfo element), so
		              override this when you apply the template if you want to keep the first (only valid for one)
		              onlink for a citation anywhere else (sources, larger work cited, cross references, etc)
		-->
		<xsl:param name="use-onlinks" select="false()"/>
		<gmd:CI_Citation>
			<gmd:title>
				<gco:CharacterString>
					<xsl:value-of select="fn:normalize-space(title)"/>
				</gco:CharacterString>
			</gmd:title>
			<gmd:date>
				<gmd:CI_Date>
					<gmd:date>
						<xsl:variable name='pubdate' select="fn:normalize-space(pubdate)"/>
						<xsl:variable name='pubtime' select="fn:normalize-space(pubtime)"/>
						
						<xsl:variable name="pub-datetime">
							<xsl:call-template name="format-datetime">
								<xsl:with-param name="datestring" select="$pubdate"/>
								<xsl:with-param name="timestring" select="$pubtime"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="fn:contains($pub-datetime, 'unknown') or fn:contains($pub-datetime, 'present')">
								<xsl:attribute name="gco:nilReason" select="'unknown'"/>
							</xsl:when>
							<xsl:when test="fn:contains($pub-datetime, 'T') and fn:contains($pub-datetime, ':')">
								<gco:DateTime>
									<xsl:value-of select="$pub-datetime"/>
								</gco:DateTime>
							</xsl:when>
							<xsl:otherwise>
								<gco:Date>
									<xsl:value-of select="$pub-datetime"/>
								</gco:Date>
							</xsl:otherwise>
						</xsl:choose>
					</gmd:date>
					
					<gmd:dateType>
						<gmd:CI_DateTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode"
							codeListValue="publication">publication</gmd:CI_DateTypeCode>
					</gmd:dateType>
				</gmd:CI_Date>
			</gmd:date>
			<xsl:for-each select="edition">
				<gmd:edition>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(.)"/>
					</gco:CharacterString>
				</gmd:edition>
			</xsl:for-each>
			<!-- TODO: check on this -->
			<xsl:for-each select="distinfo/resdesc">
				<gmd:identifier>
					<gmd:MD_Identifier>
						<gmd:code>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(.)"/>
							</gco:CharacterString>
						</gmd:code>
					</gmd:MD_Identifier>
				</gmd:identifier>
			</xsl:for-each>
			<xsl:for-each select="origin">
				<gmd:citedResponsibleParty>
					<gmd:CI_ResponsibleParty>
						<gmd:organisationName>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(.)"/>
							</gco:CharacterString>
						</gmd:organisationName>
						<gmd:role>
							<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
								codeListValue="originator">originator</gmd:CI_RoleCode>
						</gmd:role>
					</gmd:CI_ResponsibleParty>

				</gmd:citedResponsibleParty>
			</xsl:for-each>
			<xsl:for-each select="pubinfo">
				<gmd:citedResponsibleParty>
					<gmd:CI_ResponsibleParty>
						<gmd:organisationName>
							<gco:CharacterString>
								<xsl:value-of select="publish"/>
							</gco:CharacterString>
						</gmd:organisationName>
						<gmd:contactInfo>
							<gmd:CI_Contact>
								<gmd:address>
									<gmd:CI_Address>
										<gmd:city>
											<gco:CharacterString>
												<xsl:value-of select="fn:substring-before(pubplace, ',')"/>
											</gco:CharacterString>
										</gmd:city>
										<gmd:administrativeArea>
											<gco:CharacterString>
												<xsl:value-of select="fn:substring-after(pubplace, ',')"/>
											</gco:CharacterString>
										</gmd:administrativeArea>
									</gmd:CI_Address>
								</gmd:address>
								<xsl:if test="$use-onlinks">
									<gmd:onlineResource>
										<gmd:CI_OnlineResource>
											<gmd:linkage>
												<!-- only take the first link, if there's more than one -->
												<gmd:URL><xsl:value-of select="fn:normalize-space(../onlink[1])"/></gmd:URL>
											</gmd:linkage>
										</gmd:CI_OnlineResource>
									</gmd:onlineResource>
								</xsl:if>
							</gmd:CI_Contact>
						</gmd:contactInfo>
						<gmd:role>
							<gmd:CI_RoleCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
								codeListValue="publisher">publisher</gmd:CI_RoleCode>
						</gmd:role>
					</gmd:CI_ResponsibleParty>
				</gmd:citedResponsibleParty>
			</xsl:for-each>
			<!-- TODO: presentation form empty? see 0c651074-8b21-4658-8f80-03857744409e -->
			<xsl:if test="geoform">
				<gmd:presentationForm>
					<xsl:variable name="pres-form">
						<xsl:call-template name="get-presentationformcode">
							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(geoform))"/>
						</xsl:call-template>
					</xsl:variable>
					<gmd:CI_PresentationFormCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode"
						codeListValue="{$pres-form}"/>
				</gmd:presentationForm>
			</xsl:if>
			<xsl:for-each select="serinfo">
				<gmd:series>
					<gmd:CI_Series>
						<gmd:name>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(sername)"/>
							</gco:CharacterString>
						</gmd:name>
						<gmd:issueIdentification>
							<gco:CharacterString>
								<xsl:value-of select="fn:normalize-space(issue)"/>
							</gco:CharacterString>
						</gmd:issueIdentification>
					</gmd:CI_Series>
				</gmd:series>
			</xsl:for-each>
			<xsl:for-each select="othercit">
				<gmd:otherCitationDetails>
					<gco:CharacterString>
						<xsl:value-of select="fn:normalize-space(.)"/>
					</gco:CharacterString>
				</gmd:otherCitationDetails>
			</xsl:for-each>
		</gmd:CI_Citation>
	</xsl:template>
</xsl:stylesheet>
